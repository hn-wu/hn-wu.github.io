<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="hnwu">
<meta property="og:url" content="http://example.com/default-index/page/2/index.html">
<meta property="og:site_name" content="hnwu">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="hnwu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/default-index/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>hnwu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hnwu</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/04/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/04/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="post-title-link" itemprop="url">线程的生命周期</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-04 16:08:52 / 修改时间：16:12:48" itemprop="dateCreated datePublished" datetime="2022-09-04T16:08:52+08:00">2022-09-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Java并发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>线程的生命周期包括新建（New）、就绪（Ready）、运行（Running）、阻塞（Blocked）和死亡（Dead）5种状态。尤其是当线程启动以后，它不可能一直“霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、就绪之间切换。</p>
<h5 id="（一）新建状态"><a href="#（一）新建状态" class="headerlink" title="（一）新建状态"></a>（一）新建状态</h5><p>当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时它和其他的Java对象一样，仅仅由Java虚拟机为其分配内存，并初始化其成员变量的值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。</p>
<h5 id="（二）就绪状态"><a href="#（二）就绪状态" class="headerlink" title="（二）就绪状态"></a>（二）就绪状态</h5><p>当线程对象调用了start()方法之后，该线程处于就绪状态，Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。</p>
<h5 id="（三）运行状态"><a href="#（三）运行状态" class="headerlink" title="（三）运行状态"></a>（三）运行状态</h5><p>如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态，如果计算机只有一个CPU，那么在任何时刻只有一个线程处于运行状态。当然，在一个多处理器的机器上，将会有多个线程并行执行；当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象。</p>
<h5 id="（四）阻塞状态"><a href="#（四）阻塞状态" class="headerlink" title="（四）阻塞状态"></a>（四）阻塞状态</h5><p>当一个线程开始运行后，它不可能一直处于运行状态，线程在运行过程中需要被中断，目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用的策略。对于采用抢占式策略的系统而言，系统会给每个可执行的线程一个小时间段来处理任务。当该时间段用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。</p>
<p>当发生如下情况时，线程将会进入阻塞状态：</p>
<ul>
<li>线程调用sleep()方法。</li>
<li>线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。</li>
<li>线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。</li>
<li>线程调用wait()方法，在等待某个通知（notify）。</li>
<li>程序调用了线程的suspend()方法将该线程挂起。但这个方法容易导致死锁，所以应该尽量避免使用该方法。</li>
</ul>
<p>针对上面几种情况，当发生如下特定的情况时可以解除上面的阻塞，让该线程重新进入就绪状态：</p>
<ul>
<li>调用sleep()方法的线程经过了指定时间(不释放锁)。</li>
<li>线程调用的阻塞式IO方法已经返回。</li>
<li>线程成功地获得了试图取得的同步监视器。</li>
<li>线程正在等待某个通知时，其他线程发出了一个通知。</li>
<li>处于挂起状态的线程被调用了resume()恢复方法。</li>
</ul>
<h5 id="（五）死亡状态"><a href="#（五）死亡状态" class="headerlink" title="（五）死亡状态"></a>（五）死亡状态</h5><p>线程会以如下三种方式结束，结束后就处于死亡状态：</p>
<ul>
<li>run()或call()方法执行完成，线程正常结束。</li>
<li>线程抛出一个未捕获的Exception或Error。</li>
<li>直接调用该线程的stop()方法来结束该线程，该方法容易导致死锁，通常不推荐使用</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190812213026533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDY0ODA5,size_16,color_FFFFFF,t_70" alt="线程的生命周期"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/03/CMS%E5%92%8CG1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/03/CMS%E5%92%8CG1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" class="post-title-link" itemprop="url">CMS和G1垃圾收集器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-03 20:53:03 / 修改时间：20:54:04" itemprop="dateCreated datePublished" datetime="2022-09-03T20:53:03+08:00">2022-09-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="一、CMS收集器"><a href="#一、CMS收集器" class="headerlink" title="一、CMS收集器"></a>一、CMS收集器</h4><h5 id="（一）CMS介绍"><a href="#（一）CMS介绍" class="headerlink" title="（一）CMS介绍"></a>（一）CMS介绍</h5><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器</strong>。这是因为CMS收集器工作时，GC工作线程与用户线程可以<code>并发</code>执行，以此来达到降低收集停顿时间的目的。</p>
<p>CMS收集器仅作用于<strong>老年代</strong>的收集，是基于<code>标记-清除算法</code>的，</p>
<h5 id="（二）CMS运作过程"><a href="#（二）CMS运作过程" class="headerlink" title="（二）CMS运作过程"></a>（二）CMS运作过程</h5><ul>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ul>
<p>其中，<code>初始标记</code>、<code>重新标记</code>这两个步骤仍然需要Stop-the-world。</p>
<p>初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程</p>
<p>重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始阶段稍长一些，但远比并发标记的时间短。</p>
<blockquote>
<p>CMS以流水线方式拆分了收集周期，将耗时长的操作单元保持与应用线程并发执行。只将那些必需STW才能执行的操作单元单独拎出来，控制这些单元在恰当的时机运行，并能保证仅需短暂的时间就可以完成。这样，在整个收集周期内，只有<strong>两次短暂的暂停（初始标记和重新标记）</strong>，<strong>达到了近似并发的目的</strong>。</p>
</blockquote>
<h5 id="（三）CMS优缺点"><a href="#（三）CMS优缺点" class="headerlink" title="（三）CMS优缺点"></a>（三）CMS优缺点</h5><p>CMS收集器<strong>优点</strong>：并发收集、低停顿。</p>
<p>CMS收集器<strong>缺点</strong>：</p>
<ul>
<li>CMS收集器对CPU资源非常敏感。</li>
<li>CMS收集器无法处理浮动垃圾（Floating Garbage）。</li>
<li>CMS收集器是基于标记-清除算法，该算法的缺点都有。</li>
</ul>
<p>CMS收集器之所以能够做到并发，根本原因在于<strong>采用基于“标记-清除”的算法并对算法过程进行了细粒度的分解</strong>。</p>
<h4 id="二、G1收集器"><a href="#二、G1收集器" class="headerlink" title="二、G1收集器"></a>二、G1收集器</h4><h5 id="（一）G1介绍"><a href="#（一）G1介绍" class="headerlink" title="（一）G1介绍"></a>（一）G1介绍</h5><p>G1重新定义了堆空间，打破了原有的分代模型，将堆划分为一个个区域。这么做的目的是在进行收集时不必在全堆范围内进行，这是它最显著的特点。区域划分的好处就是带来了停顿时间可预测的收集模型：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。</p>
<h5 id="（二）G1运行步骤"><a href="#（二）G1运行步骤" class="headerlink" title="（二）G1运行步骤"></a>（二）G1运行步骤</h5><ul>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>筛选清除</li>
</ul>
<h5 id="（三）G1特点"><a href="#（三）G1特点" class="headerlink" title="（三）G1特点"></a>（三）G1特点</h5><ul>
<li><p><strong>并行与并发</strong>：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-the-world停顿的时间，部分其他收集器原来需要停顿Java线程执行的GC操作，G1收集器仍然可以通过<strong>并发</strong>的方式让Java程序继续运行。</p>
</li>
<li><p>分代收集</p>
</li>
<li><p>空间整合：与CMS的标记-清除算法不同，G1从整体来看是基于<strong>标记-整理算法</strong>实现的收集器，从局部（两个Region之间）上来看是基于“<strong>复制</strong>”算法实现的。但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。<strong>这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC</strong>。</p>
</li>
<li><p>可预测的停顿：这是G1相对于CMS的一个优势，降低停顿时间是G1和CMS共同的关注点。</p>
<p>在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。在堆的结构设计时，G1打破了以往将收集范围固定在新生代或老年代的模式，G1将堆分成许多相同大小的区域单元，每个单元称为Region。Region是一块地址连续的内存空间</p>
</li>
</ul>
<p>参考链接：</p>
<p>深入浅出Java虚拟机</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/03/%E8%85%BE%E8%AE%AF%E5%AE%89%E5%8D%93%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/03/%E8%85%BE%E8%AE%AF%E5%AE%89%E5%8D%93%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">《腾讯安卓自动化测试实战》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-03 16:43:30 / 修改时间：16:44:56" itemprop="dateCreated datePublished" datetime="2022-09-03T16:43:30+08:00">2022-09-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B9%A6%E7%B1%8D%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">书籍记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="一、自动化测试框架及应用领域综述"><a href="#一、自动化测试框架及应用领域综述" class="headerlink" title="一、自动化测试框架及应用领域综述"></a>一、自动化测试框架及应用领域综述</h4><h5 id="（一）自动化测试框架执行流程"><a href="#（一）自动化测试框架执行流程" class="headerlink" title="（一）自动化测试框架执行流程"></a>（一）自动化测试框架执行流程</h5><ol>
<li>获取坐标或控件并模拟用户操作</li>
<li>对结果进行判断（截图比较、控件状态比较、日志分析）</li>
<li>测试报告的产出</li>
</ol>
<h5 id="（二）移动端自动化测试应用场景"><a href="#（二）移动端自动化测试应用场景" class="headerlink" title="（二）移动端自动化测试应用场景"></a>（二）移动端自动化测试应用场景</h5><ol>
<li>性能测试</li>
<li>稳定性测试</li>
<li>功能测试</li>
<li>兼容性测试</li>
<li>接口测试</li>
<li>单元测试</li>
<li>线上监控测试</li>
</ol>
<h4 id="二、Monkey基本原理及扩展应用"><a href="#二、Monkey基本原理及扩展应用" class="headerlink" title="二、Monkey基本原理及扩展应用"></a>二、Monkey基本原理及扩展应用</h4><h5 id="（一）Monkey介绍"><a href="#（一）Monkey介绍" class="headerlink" title="（一）Monkey介绍"></a>（一）Monkey介绍</h5><p>Monkey是Google提供的一个命令行工具，可运行在模拟器或实际设备中。它向系统发送伪随机的用户事件，模拟用户的按键输入、触摸屏输入、手势输入等，从而对正在运行的应用程序进行压力测试，目的是看设备多长时间会出现异常，并观察系统的稳定性和容错性能。</p>
<h5 id="（二）Monkey启动的命令行脚本"><a href="#（二）Monkey启动的命令行脚本" class="headerlink" title="（二）Monkey启动的命令行脚本"></a>（二）Monkey启动的命令行脚本</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// options表示Monkey执行的可配置参数，是可选项</span><br><span class="line">// count表示Monkey执行的事件数，为必选项。</span><br><span class="line">monkey [options] &lt;count&gt;</span><br></pre></td></tr></table></figure>

<p>Options参数类别</p>
<ol>
<li>基本配置类参数</li>
<li>事件类型和频率参数</li>
<li>约束限制类参数</li>
<li>调试类参数</li>
<li>官方隐藏类参数</li>
</ol>
<h5 id="（三）Monkey事件"><a href="#（三）Monkey事件" class="headerlink" title="（三）Monkey事件"></a>（三）Monkey事件</h5><p>触摸事件、手势事件、二指缩放事件、轨迹事件、屏幕旋转事件、基本导航事件、主要导航事件、系统按键事件、启动Activity事件、键盘事件、其他类型事件</p>
<h5 id="（四）Monkey测试实例"><a href="#（四）Monkey测试实例" class="headerlink" title="（四）Monkey测试实例"></a>（四）Monkey测试实例</h5><p>情况一：常规稳定性测试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">adb  shell  monkey  </span><br><span class="line">//使用-p参数来制定测试应用的包名（Package）</span><br><span class="line">-p  com.xxx.xxx  </span><br><span class="line">//使用--pct-xxx参数限制Monkey执行的事件类型和占比</span><br><span class="line">--pct-touch  40  </span><br><span class="line">--pct-motion  25  </span><br><span class="line">--pct-appswitch  10  </span><br><span class="line">--pct-rotation  5</span><br><span class="line">//使用--pct-xxx参数限制Monkey执行的事件类型和占比</span><br><span class="line">-s  12358</span><br><span class="line">//使用--pct-xxx参数限制Monkey执行的事件类型和占比</span><br><span class="line">--throttle  400  </span><br><span class="line">//使用--pct-xxx参数限制Monkey执行的事件类型和占比</span><br><span class="line">--ignore-crashes</span><br><span class="line">//使用-v指定log的详细级别</span><br><span class="line">--ignore-timeouts</span><br><span class="line">-v 500000</span><br></pre></td></tr></table></figure>

<p>情况二：自定义脚本的稳定性测试</p>
<p>常规Monkey测试执行的是随机的事件流，如果想让Monkey测试某个特定场景（执行固定的事件流），这时候就需要用到自定义脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">头文件，控制Monkey发送消息的参数，固定写即可</span>        </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">脚本类型，一般不用更改</span>        </span><br><span class="line">type=raw events        </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">脚本执行次数，但是由于Monkey命令本身可以指定执行次数，所以这里的设置是不生效的        count=10</span>        </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令执行速率，速率也可以通过Monkey命令设置，这里的设置是不生效的</span>        </span><br><span class="line">speed=1.0        </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以下为Monkey命令</span>        </span><br><span class="line">start data&gt;&gt;        </span><br><span class="line">LaunchActivity（pkg_name, cl_name）        </span><br><span class="line">DispatchPress(KEYCODE_HOME)        …</span><br></pre></td></tr></table></figure>

<p>情况三：结合辅助命令，获取更多信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//logcat日志信息</span><br><span class="line">adb shell logcat -v time&gt;log.txt</span><br><span class="line">//内存信息</span><br><span class="line">adb shell dumpsys meminfo &lt;进程名&gt;</span><br><span class="line">//CPU消耗信息</span><br><span class="line">adb shell top -n 1 |find“进程名”</span><br><span class="line">//电量信息</span><br><span class="line">adb shell dumpsys battery</span><br><span class="line">//GPU信息</span><br><span class="line">adb shell dumpsys gfxinfo &lt;进程名&gt;</span><br><span class="line">//流量信息</span><br><span class="line">adb shell cat/proc/uid_stat/&lt;被测应用的uid&gt;/tcp_rcv</span><br></pre></td></tr></table></figure>

<h5 id="（五）Monkey原理"><a href="#（五）Monkey原理" class="headerlink" title="（五）Monkey原理"></a>（五）Monkey原理</h5><p>见书</p>
<h4 id="三、Appium框架解析及实践"><a href="#三、Appium框架解析及实践" class="headerlink" title="三、Appium框架解析及实践"></a>三、Appium框架解析及实践</h4><h5 id="（一）Appium介绍"><a href="#（一）Appium介绍" class="headerlink" title="（一）Appium介绍"></a>（一）Appium介绍</h5><p>Appium是一个开源的、跨平台的自动化测试框架，该框架适用于Native Application、Mobile Web Application或Hybrid Application的自动化测试</p>
<h5 id="（二）Appium原理"><a href="#（二）Appium原理" class="headerlink" title="（二）Appium原理"></a>（二）Appium原理</h5><p>Appium是在手机操作系统自带的测试框架基础上实现的</p>
<ol>
<li>Android（版本&gt;4.2）:UIAutomator</li>
<li>Android（版本≤4.2）:Selendroid</li>
<li>iOS：UIAutomation</li>
</ol>
<h5 id="（三）Appium组成"><a href="#（三）Appium组成" class="headerlink" title="（三）Appium组成"></a>（三）Appium组成</h5><p>Appium由客户端（Appium Client）和服务器（Appium Server）两部分组成，客户端与服务器端之间通过JSON Wire Protocol进行通信。</p>
<p>（1）Appium服务器。Appium服务器是Appium框架的核心。它是一个基于Node.js实现的HTTP服务器。Appium服务器的主要功能是接受从Appium客户端发起的连接，监听从客户端发送来的命令，将命令发送给bootstrap.jar（iOS手机为bootstrap.js）执行，并将命令的执行结果通过HTTP应答反馈给Appium客户端。</p>
<p>（2）Bootstrap.jar。Bootstrap.jar是在Android手机上运行的一个应用程序，它在手机上扮演TCP服务器的角色。当Appium服务器需要运行命令时，Appium服务器会与Bootstrap. jar建立TCP通信，并把命令发送给Bootstrap.jar; Bootstrap.jar负责运行测试命令。</p>
<p>（3）Appium客户端。它主要是指实现了Appium功能的WebDriver协议的客户端Library，它负责与Appium服务器建立连接，并将测试脚本的指令发送到Appium服务器。现有的客户端Library有多种语言的实现，包括Ruby、Python、Java、JavaScript（Node. js）、Object C、PHP和C#。Appium的测试是在这些Library的基础上进行开发的。</p>
<p>（4）Session。Appium的客户端和服务端之间进行通信都必须在一个Session的上下文中进行。客户端在发起通信的时候首先会发送一个叫作“Desired Capabilities”的JSON对象给服务器。服务器收到该数据后，会创建一个session并将session的ID返回到客户端。之后客户端可以用该session的ID发送后续的命令。</p>
<p>（5）Desired Capabilities。Desired Capabilities是一组设置的键值对的集合，其中键对应设置的名称，而值对应设置的值。Desired Capabilities主要用于通知Appium服务器建立需要的Session，其中一些设置可以在Appium运行过程中改变Appium服务器的运行行为</p>
<h5 id="（三）Appium优缺点"><a href="#（三）Appium优缺点" class="headerlink" title="（三）Appium优缺点"></a>（三）Appium优缺点</h5><p>优点：</p>
<ol>
<li>Appium支持多种应用程序的测试。可以测试移动Native App、Hybrid App和Web App。</li>
<li>被测试的应用程序不需要特殊编译。Appium的测试对象一般不需要做特殊修改，如不需要引入任何额外的测试SDK，不需要添加任何的权限，也不要求被测程序与脚本的签名一致，所以可以直接对发布的程序进行测试，但Hybrid App测试可能需要做一点儿修改</li>
<li>Appium的脚本不限制语言和工具。由于Appium的客户端支持多种测试语言，测试人员可以选择熟悉的语言开发测试脚本，而其他的测试工具一般只能使用特定的语言。</li>
<li>Appium支持应用之间跳转的测试。它可以用于测试多个应用程序相互交户的场景。</li>
<li>Appium是一个跨平台的测试框架，可以使用同一个API开发出在Android和iOS上都可以运行的脚本。</li>
</ol>
<p>缺点：</p>
<ol>
<li>该工具必须连接电脑才能实施自动化测试，遇到需要脱机执行的场景就不能满足需求，如电池测试。</li>
<li>该工具只能用于UI的自动化测试，在很多情况下测试验证只能通过界面来进行。</li>
</ol>
<h5 id="（四）Appium运行中的问题"><a href="#（四）Appium运行中的问题" class="headerlink" title="（四）Appium运行中的问题"></a>（四）Appium运行中的问题</h5><p><strong>情况一：</strong></p>
<p>用例运行时受前一个用例运行的影响，程序状态不正确导致测试脚本运行错误。最常遇到的是前一个脚本异常退出，Session还没有正常结束，可能导致后面用例在建立Session时失败。</p>
<p>解决方法：首先，用例之间不相互耦合，每一个用例都是一个可独立运行的方法，不依赖任何其他的用例。其次，每个测试脚本都从程序启动状态开始运行，因为中间状态不能确保正确。如果用例会对程序有一些设置，那么每个用例结束后将设置状态恢复到初始状态。最后，在setUp和tearDown方法中初始化与断开Appium的连接，保证Appium服务器是一个清洁的环境。</p>
<p><strong>情况二：</strong></p>
<p>脚本包含多个用例，如果用例查找控件失败，则会抛出异常，导致整个脚本都退出了，后续用例将不能正常运行。例如，在刚开始的时候脚本没有做任何异常捕获，当用例出现异常时直接就中断了该脚本的运行，后面的用例就不可能再被运行了。</p>
<p>笔者的解决方法是将每一个测试脚本的代码都包含在try-except中，保证测试脚本中的异常都能被每个用例捕获，即使当前用例失败了，后续用例也可以正常运行</p>
<p><strong>情况三：</strong></p>
<p>在程序运行过程中，未预期的消息框弹出，导致测试脚本运行出错。例如我们比较容易遇到启动地图时提示用户需要开启Wi-Fi或者GPS的情况。</p>
<p>只能尽量保证测试环境的清洁，在setUp方法中就将Wi-Fi和GPS打开，并在启动地图后稍作等待，然后判断是否存在Dialog，有则清除掉，降低这类问题出现的概率。</p>
<h4 id="四、安卓-APP速度测试"><a href="#四、安卓-APP速度测试" class="headerlink" title="四、安卓 APP速度测试"></a>四、安卓 APP速度测试</h4><p>见书</p>
<h4 id="五、BVT测试实例"><a href="#五、BVT测试实例" class="headerlink" title="五、BVT测试实例"></a>五、BVT测试实例</h4><p>见书</p>
<h4 id="六、兼容性测试实践"><a href="#六、兼容性测试实践" class="headerlink" title="六、兼容性测试实践"></a>六、兼容性测试实践</h4><h5 id="（一）兼容性测试介绍"><a href="#（一）兼容性测试介绍" class="headerlink" title="（一）兼容性测试介绍"></a>（一）兼容性测试介绍</h5><p>兼容性测试主要是指测试Android应用的功能，在市面上所有的Android设备上能否正常运行</p>
<h5 id="（二）手工测试"><a href="#（二）手工测试" class="headerlink" title="（二）手工测试"></a>（二）手工测试</h5><p>见书</p>
<h5 id="（三）自动化测试"><a href="#（三）自动化测试" class="headerlink" title="（三）自动化测试"></a>（三）自动化测试</h5><ol>
<li>安装卸载</li>
<li>稳定性测试（控件遍历、Monkey随机测试）</li>
<li>功能测试（自动化+人工验证）</li>
</ol>
<h5 id="（四）云平台测试"><a href="#（四）云平台测试" class="headerlink" title="（四）云平台测试"></a>（四）云平台测试</h5>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/30/%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/30/%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8/" class="post-title-link" itemprop="url">拦截器和过滤器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-30 20:58:25" itemprop="dateCreated datePublished" datetime="2022-08-30T20:58:25+08:00">2022-08-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="拦截器和过滤器"><a href="#拦截器和过滤器" class="headerlink" title="拦截器和过滤器"></a>拦截器和过滤器</h2><h4 id="一、过滤器"><a href="#一、过滤器" class="headerlink" title="一、过滤器"></a>一、过滤器</h4><p><strong>过滤器的应用场景</strong>：跨域问题解决，编码转换</p>
<p>过滤器Filter基于Servlet实现，将传入的request和response提前过滤掉一些信息或者提前设置一些参数，再对传入Servlet或Struts2中的action进行业务逻辑处理。</p>
<p>比如过滤掉非法url（不是login.do的地址请求，如果用户没有登陆都过滤掉），或者在传入Servlet或Struts2的action前统一设置字符集，或者去除掉一些非法字符。</p>
<p>Filter过滤器随着web应用的启动而启动，只初始化一次。</p>
<h4 id="二、拦截器"><a href="#二、拦截器" class="headerlink" title="二、拦截器"></a>二、拦截器</h4><p><strong>拦截器的应用场景</strong>：权限控制，日志打印，参数校验</p>
<p>拦截器是SpringMVC中实现的一种基于Java反射（动态代理）机制的方法增强工具，拦截器的实现是继承HandlerInterceptor 接口，并实现接口的preHandle、postHandle和afterCompletion方法。</p>
<p>preHandle：请求方法前置拦截，该方法会在Controller处理之前进行调用，Spring中可以有多个Interceptor，这些拦截器会按照设定的Order顺序调用，当有一个拦截器在preHandle中返回false的时候，请求就会终止。</p>
<p>postHandle：若preHandle返回结果为true时，在Controller方法执行之后，视图渲染之前被调用</p>
<p>afterCompletion：若preHandle返回true，并且整个请求结束之后，执行该方法。</p>
<h4 id="三、拦截器和过滤器之间的区别"><a href="#三、拦截器和过滤器之间的区别" class="headerlink" title="三、拦截器和过滤器之间的区别"></a>三、拦截器和过滤器之间的区别</h4><p>①拦截器基于java反射，过滤器属于Servlet级别<br>②拦截器不依赖于servlet容器，而过滤器依赖于servlet容器。<br>③拦截器只对action请求起作用，而过滤器则可以对几乎所有的请求起作用。<br>④拦截器可以访问action上下文、值、栈里面的对象，而过滤器不可以。<br>⑤在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。<br>⑥拦截器可以获取IOC容器中的各个bean，而过滤器不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</p>
<h4 id="四、拦截器与过滤器执行流程"><a href="#四、拦截器与过滤器执行流程" class="headerlink" title="四、拦截器与过滤器执行流程"></a>四、拦截器与过滤器执行流程</h4><p><img src="https://img-blog.csdnimg.cn/20190620230108441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDUwMjgwNA==,size_16,color_FFFFFF,t_70"></p>
<p><img src="https://img-blog.csdnimg.cn/20190620230043280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDUwMjgwNA==,size_16,color_FFFFFF,t_70"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/30/Explain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/30/Explain/" class="post-title-link" itemprop="url">Explain</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-30 20:50:44" itemprop="dateCreated datePublished" datetime="2022-08-30T20:50:44+08:00">2022-08-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h2><table>
<thead>
<tr>
<th align="left">列明</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">select_type</td>
<td align="left">表示select查询类型，如普通查询、联合查询、子查询</td>
</tr>
<tr>
<td align="left">type</td>
<td align="left">本次查询表联接类型，从这里可以看到本次查询大概的效率。</td>
</tr>
<tr>
<td align="left">key</td>
<td align="left">最终选择的索引，如果没有索引的话，本次查询效率通常很差。</td>
</tr>
<tr>
<td align="left">key_len</td>
<td align="left">本次查询用于结果过滤的索引实际长度。</td>
</tr>
<tr>
<td align="left">rows</td>
<td align="left">预计需要扫描的记录数，预计需要扫描的记录数越小越好。</td>
</tr>
<tr>
<td align="left">Extra</td>
<td align="left">额外附加信息，主要确认是否出现 Using filesort、Using temporary 这两种情况。</td>
</tr>
</tbody></table>
<p>其中，type包含以下几种结果，从上之下依次是最差到最好：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ALL</td>
<td align="left">执行full table scan，这是最差的一种方式。</td>
</tr>
<tr>
<td align="left">index</td>
<td align="left">执行full index scan，并且可以通过索引完成结果扫描并且直接从索引中取的想要的结果数据，也就是可以避免回表，比ALL略好，因为索引文件通常比全部数据要来的小。</td>
</tr>
<tr>
<td align="left">range</td>
<td align="left">利用索引进行范围查询，比index略好。</td>
</tr>
<tr>
<td align="left">index_subquery</td>
<td align="left">子查询中可以用到索引。</td>
</tr>
<tr>
<td align="left">unique_subquery</td>
<td align="left">子查询中可以用到唯一索引，效率比 index_subquery 更高些。</td>
</tr>
<tr>
<td align="left">index_merge</td>
<td align="left">可以利用index merge特性用到多个索引，提高查询效率。</td>
</tr>
<tr>
<td align="left">ref_or_null</td>
<td align="left">表连接类型是ref，但进行扫描的索引列中可能包含NULL值。</td>
</tr>
<tr>
<td align="left">fulltext</td>
<td align="left">全文检索。</td>
</tr>
<tr>
<td align="left">ref</td>
<td align="left">基于索引的等值查询，或者表间等值连接。</td>
</tr>
<tr>
<td align="left">eq_ref</td>
<td align="left">表连接时基于主键或非NULL的唯一索引完成扫描，比ref略好。</td>
</tr>
<tr>
<td align="left">const</td>
<td align="left">基于主键或唯一索引唯一值查询，最多返回一条结果，比eq_ref略好。</td>
</tr>
<tr>
<td align="left">system</td>
<td align="left">查询对象表只有一行数据，这是最好的情况。</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/20/Http%E7%8A%B6%E6%80%81%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/20/Http%E7%8A%B6%E6%80%81%E7%A0%81/" class="post-title-link" itemprop="url">Http状态码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-20 19:32:32 / 修改时间：19:33:10" itemprop="dateCreated datePublished" datetime="2022-08-20T19:32:32+08:00">2022-08-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-（信息提示）"><a href="#1-（信息提示）" class="headerlink" title="1**（信息提示）"></a>1**（信息提示）</h2><p>100 - Continue 初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新）<br>101 - Switching Protocols 服务器将遵从客户的请求转换到另外一种协议（HTTP 1.1新）</p>
<h2 id="2-开头-（请求成功）表示成功处理了请求的状态代码。"><a href="#2-开头-（请求成功）表示成功处理了请求的状态代码。" class="headerlink" title="2**开头 （请求成功）表示成功处理了请求的状态代码。"></a>2**开头 （请求成功）表示成功处理了请求的状态代码。</h2><p>200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。<br>201 （已创建） 请求成功并且服务器创建了新的资源。<br>202 （已接受） 服务器已接受请求，但尚未处理。<br>203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。<br>204 （无内容） 服务器成功处理了请求，但没有返回任何内容。<br>205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。<br>206 （部分内容） 服务器成功处理了部分 GET 请求。</p>
<h2 id="3-开头-（请求被重定向）表示要完成请求，需要进一步操作。-通常，这些状态代码用来重定向。"><a href="#3-开头-（请求被重定向）表示要完成请求，需要进一步操作。-通常，这些状态代码用来重定向。" class="headerlink" title="3** 开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。"></a>3** 开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</h2><p>300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br>301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。<br>302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。<br>304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。<br>305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。<br>307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p>
<h2 id="4-开头-（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。"><a href="#4-开头-（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。" class="headerlink" title="4**开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。"></a>4**开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。</h2><p>400 （错误请求） 服务器不理解请求的语法。<br>401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>403 （禁止） 服务器拒绝请求。<br>404 （未找到） 服务器找不到请求的网页。<br>405 （方法禁用） 禁用请求中指定的方法。<br>406 （不接受） 无法使用请求的内容特性响应请求的网页。<br>407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。<br>408 （请求超时） 服务器等候请求时发生超时。<br>409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。<br>410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。<br>411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。<br>412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。<br>413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。<br>415 （不支持的媒体类型） 请求的格式不受请求页面的支持。<br>416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。<br>417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。</p>
<h2 id="5-开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。-这些错误可能是服务器本身的错误，而不是请求出错。"><a href="#5-开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。-这些错误可能是服务器本身的错误，而不是请求出错。" class="headerlink" title="5**开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。"></a>5**开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</h2><p>500 （服务器内部错误） 服务器遇到错误，无法完成请求。<br>501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br>502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br>503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。<br>504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/20/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/20/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">SpringBoot自动装配原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-20 11:04:28 / 修改时间：11:05:22" itemprop="dateCreated datePublished" datetime="2022-08-20T11:04:28+08:00">2022-08-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="SpringBoot自动装配原理"><a href="#SpringBoot自动装配原理" class="headerlink" title="SpringBoot自动装配原理"></a>SpringBoot自动装配原理</h2><p>自动装配依托@Import的强大功能和Spring的SPI机制，通过SPI机制发现类，通过@Import将类注册到Spring中。</p>
<h5 id="一、自动装配的过程"><a href="#一、自动装配的过程" class="headerlink" title="一、自动装配的过程"></a>一、自动装配的过程</h5><ol>
<li>Spring Boot通过@EnableAutoConfiguration注解开启自动配置,加载spring.factories中注册的各种AutoConfiguration类</li>
<li>当某个AutoConfiguration类满足其注解@Conditional指定的生效条件（Starters提供的依赖、配置或Spring容器中是否存在某个Bean等）时,实例化该AutoConfiguration类中定义的Bean（组件等）,并注入Spring容器,就可以完成依赖框架的自动配置。 </li>
<li>这些AutoConfiguration类的原理就是通过@Import注解将其属性类properties全部注册到spring容器中，属性类通过注解@ConfigurationProperties从配置文件里面取到配置值，之后将关键的类注册为bean自动注入属性类进行初始化，完成自动装配的功能</li>
</ol>
<h5 id="二、-EnableAutoConfiguration-作用"><a href="#二、-EnableAutoConfiguration-作用" class="headerlink" title="二、@EnableAutoConfiguration 作用"></a>二、@EnableAutoConfiguration 作用</h5><p>寻找每个jar里面的META-INF&#x2F;spring-factories文件，然后将文件中的类全部实例化</p>
<h5 id="三、-EnableAutoConfiguration-原理"><a href="#三、-EnableAutoConfiguration-原理" class="headerlink" title="三、@EnableAutoConfiguration 原理"></a>三、@EnableAutoConfiguration 原理</h5><ol>
<li>ImportSelector 该接口的方法的返回值都会被纳入到spring容器管理中 </li>
<li>SpringFactoriesLoader类可以从classpath中搜索所有META-INF&#x2F;spring.factories配置文件,并读取配置</li>
</ol>
<h5 id="四、SpringFactoriesLoader实现原理"><a href="#四、SpringFactoriesLoader实现原理" class="headerlink" title="四、SpringFactoriesLoader实现原理"></a>四、SpringFactoriesLoader实现原理</h5><p><strong>SpringFactoriesLoader这个工具类</strong> 和 <code>JDK</code>的 <code>SPI</code>原理一样，不过它比 SPI 更好的点在于不会一次性加载所有的类，而是根据 key 进行加载。SpringFactoriesLoader 的 作 用 是 从classpath&#x2F;META-INF&#x2F;spring.factories 文件中，根据 key 来加载对应的类到 spring IoC 容器中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fcb-it/p/12905525.html">https://www.cnblogs.com/fcb-it/p/12905525.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/16/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/16/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/" class="post-title-link" itemprop="url">Redis持久化策略</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-16 11:34:32 / 修改时间：11:36:00" itemprop="dateCreated datePublished" datetime="2022-08-16T11:34:32+08:00">2022-08-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Redis-持久化策略"><a href="#Redis-持久化策略" class="headerlink" title="Redis 持久化策略"></a>Redis 持久化策略</h2><p>Redis4.0之后,Redis有RDB持久化、AOF持久化、RDB-AOF混合持久化这三种持久化方式。 </p>
<h4 id="一、RDB策略"><a href="#一、RDB策略" class="headerlink" title="一、RDB策略"></a>一、RDB策略</h4><p>RDB持久化是**将当前进程数据以生成快照的方式保存到硬盘的过程,**也是Redis默认的持久化机制。RDB会创建一个经过压缩的二进制文件,这个文件以’.rdb‘结尾,内部存储了各个数据库的键值对等信息。</p>
<h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><p>RDB持久化主要是通过SAVE和BGSAVE两个命令对Redis数据库中当前的数据做snapshot并生成rdb文件来实现的。</p>
<p><strong>save 命令</strong>会一直阻塞当前Redis服务器到RBD过程完成为止,所以这种方式在操作内存比较大的实例时会造成长时间阻塞,因此线上环境不建议使用,该命令已经被废弃。</p>
<p><strong>gsave命令</strong>会让Redis进程执行fork创建子进程,由子进程负责RBD持久化过程,完成后自动结束,因此只在fork阶段发生阻塞,一般阻塞的时间也不会很长。因此Redis内部所涉及的几乎所有RDB操作都采用了bgsave的方式。</p>
<p>在Redis启动的时候会检测rdb文件，然后载入rdb文件中未过期的数据到服务器中</p>
<p>在指定的时间间隔内将内存中的数据集快照写入内存， 也就是行话讲的Snapshot快照，他恢复时是将快照文件直接读到内存中。</p>
<p>Redis会单独创建一个子进程来持节话，会先将数据写入到一个临时文件中，待持久化过程都结束了。再用这个临时文件替换上次持久化好的文件。整个过程中，主进程都不参与IO操作，这就极高的提升了性能。</p>
<h5 id="（一）优点"><a href="#（一）优点" class="headerlink" title="（一）优点"></a>（一）优点</h5><p>其生成的紧凑压缩的二进制文件体积小,使用该文件恢复数据的速度非常快</p>
<h5 id="（二）缺点"><a href="#（二）缺点" class="headerlink" title="（二）缺点"></a>（二）缺点</h5><p>BGSAVE每次运行都要执行fork操作创建子进程,这属于重量级操作,不宜频繁执行,因此,RBD没法做到实时的持久化。 </p>
<h4 id="二、AOF策略"><a href="#二、AOF策略" class="headerlink" title="二、AOF策略"></a>二、AOF策略</h4><p>Redis 默认不开启。它的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个<strong>写操作</strong>，并<strong>追加</strong>到文件中。Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
<h5 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h5><p>AOF（Append Only File）持久化是通过将存储每次执行的客户端命令，然后由一个伪客户端来执行这些命令将数据写入到服务器中的方式实现的。一共分为<code>命令追加</code>、<code>文件写入</code>、<code>文件同步</code>三个步骤完成的</p>
<p><strong>命令追加</strong>：当有修改、删除操作时，服务器会在执行完之后以协议格式将被执行的写命令追加到服务器状态的<code>aof_buf</code>缓冲区的末尾</p>
<p><strong>文件写入</strong>：Redis的服务进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求。服务器在处理文件事件时可能会执行写命令，同时会追加到<code>aof_buf</code>缓冲区，所以在每结束一次循环之前，都会调用<code>flushAppendOnlyFile</code>函数，将<code>aof_buf</code>缓冲区的数据写入到AOF文件里面。</p>
<p><strong>文件同步</strong>：<code>flushAppendOnlyFile</code>函数通过服务器配置<code>appendfsync</code>选项的值来决定的将每次循环结束之前<code>aof_buf</code>缓冲区的数据写入到AOF文件后，将以何种方式同步到AOF文件里面：</p>
<h5 id="（一）优点-1"><a href="#（一）优点-1" class="headerlink" title="（一）优点"></a>（一）优点</h5><p>与RDB持久化可能丢失大量的数据相比,AOF持久化的安全性要高很多。通过使用everysec选项,用户可以将数据丢失的时间窗口限制在1秒之内。</p>
<h5 id="（二）缺点-1"><a href="#（二）缺点-1" class="headerlink" title="（二）缺点"></a>（二）缺点</h5><ol>
<li>AOF文件存储的是协议文本,它的体积要比二进制格式的”.rdb”文件大很多。</li>
<li>AOF需要通过执行AOF文件中的命令来恢复数据库,其恢复速度比RDB慢很多。</li>
<li>AOF在进行重写时也需要创建子进程,在数据库体积较大时将占用大量资源,会导致服务器的短暂阻塞。</li>
</ol>
<p>AOF解决了数据持久化的实时性,是目前Redis主流的持久化方式。</p>
<h4 id="三、RDB-AOF混合持久化策略"><a href="#三、RDB-AOF混合持久化策略" class="headerlink" title="三、RDB-AOF混合持久化策略"></a>三、RDB-AOF混合持久化策略</h4><p>RDB-AOF混合持久化模式是Redis4.0开始引入的,这种模式是基于AOF持久化构建而来的。用户可以通过配置文件中的“aof-use-rdb-preamble yes”配置项开启AOF混合持久化。</p>
<p>Redis服务器在执行AOF重写操作时,会像执行BGSAVE命令一样,根据数据库当前的状态生成相应的RDB数据,并将其写入AOF文件中；对于重写之后执行的Redis命令,则以协议文本的方式追加到AOF文件的末尾,即RDB数据之后。 </p>
<p>通过使用RDB-AOF混合持久化,用户可以同时获得RDB持久化和AOF持久化的优点</p>
<ol>
<li>通过AOF文件包含的RDB数据来实现快速的数据恢复操作</li>
<li>通过AOF文件包含的AOF数据来将丢失数据的时间窗口限制在1s之内</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/15/%E5%8D%8F%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/15/%E5%8D%8F%E7%A8%8B/" class="post-title-link" itemprop="url">协程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-15 11:52:18 / 修改时间：11:52:51" itemprop="dateCreated datePublished" datetime="2022-08-15T11:52:18+08:00">2022-08-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h4 id="一、什么是协程"><a href="#一、什么是协程" class="headerlink" title="一、什么是协程"></a>一、什么是协程</h4><p>​	协程是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程也被叫做<strong>用户空间线程</strong>，具有<strong>内核不可见的特性</strong>。</p>
<p>​	因为是自主开辟的异步任务，所以很多人也更喜欢叫它们纤程（Fiber），或者绿色线程（GreenThread）。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p>
<h4 id="二、协程的作用"><a href="#二、协程的作用" class="headerlink" title="二、协程的作用"></a>二、协程的作用</h4><p>在传统的J2EE系统中都是基于每个请求占用一个线程去完成完整的业务逻辑（包括事务）。所以系统的吞吐能力取决于每个线程的操作耗时。如果遇到很耗时的I&#x2F;O行为，则整个系统的吞吐立刻下降，因为这个时候线程一直处于阻塞状态，如果线程很多的时候，会存在很多线程处于空闲状态（等待该线程执行完才能执行），造成了资源应用不彻底。</p>
<p>最常见的例子就是JDBC（它是同步阻塞的），这也是为什么很多人都[数据库是瓶颈的原因。这里的耗时其实是让CPU一直在等待I&#x2F;O返回，说白了线程根本没有利用CPU去做运算，而是处于空转状态。而另外过多的线程，也会带来更多的上下文开销。</p>
<p>协程的目的就是<strong>当出现长时间的I&#x2F;O操作时，通过让出目前的协程调度，执行下一个任务的方式，来消除上下文上的开销。</strong></p>
<h4 id="三、协程的特点"><a href="#三、协程的特点" class="headerlink" title="三、协程的特点"></a>三、协程的特点</h4><ol>
<li>线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率。</li>
<li>线程的默认Stack大小是1M，而协程更轻量，接近2K。因此可以在相同的内存中开启更多的协程。</li>
<li>由于在同一个线程上，因此可以避免竞争关系而使用锁。</li>
<li>适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程，遇到此种情况，更好实用线程去解决。</li>
</ol>
<h4 id="四、协程的原理"><a href="#四、协程的原理" class="headerlink" title="四、协程的原理"></a>四、协程的原理</h4><p>当出现IO阻塞的时候，由协程的调度器进行调度，通过将数据流立刻yield掉（主动让出），并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复栈，并把阻塞的结果放到这个线程上去跑，这样看上去好像跟写同步代码没有任何差别，这整个流程可以称为coroutine，而跑在由<code>coroutine</code>负责调度的线程称为<code>Fiber</code>。</p>
<p><strong>由于协程的暂停完全由程序控制，发生在用户态上；而线程的阻塞状态是由操作系统内核来进行切换，发生在内核态上。 因此，协程的开销远远小于线程的开销，也就减少了上下文的开销。</strong></p>
<h4 id="五、线程与线程比较"><a href="#五、线程与线程比较" class="headerlink" title="五、线程与线程比较"></a>五、线程与线程比较</h4><table>
<thead>
<tr>
<th></th>
<th>线程</th>
<th>协程</th>
</tr>
</thead>
<tbody><tr>
<td>占有资源</td>
<td>初始单位为1MB,固定不可变</td>
<td>初始一般为 2KB，可随需要而增大</td>
</tr>
<tr>
<td>调度所属</td>
<td>由操作系统内核完成</td>
<td>由用户自定义完成</td>
</tr>
<tr>
<td>切换开销</td>
<td>线程的私有数据、寄存器、硬件上下文</td>
<td>只有三个寄存器的值修改 - PC &#x2F; SP &#x2F; DX.</td>
</tr>
<tr>
<td>性能问题</td>
<td>资源占用高，频繁创建销毁导致性能降低</td>
<td>资源占用小,不会带来严重的性能问题</td>
</tr>
<tr>
<td>数据同步</td>
<td>需要用锁等机制确保数据的一直性和可见性</td>
<td>只有一个线程，因此不需要锁机制，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/14/%E8%B0%83%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/14/%E8%B0%83%E5%BA%A6/" class="post-title-link" itemprop="url">调度</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-14 16:06:03 / 修改时间：16:06:34" itemprop="dateCreated datePublished" datetime="2022-08-14T16:06:03+08:00">2022-08-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>一旦操作系统把进程切换到运行状态，也就意味着该进程占用着 CPU 在执行，但是当操作系统把进程切换到其他状态时，那就不能在 CPU 中执行了，于是操作系统会选择下一个要运行的进程。</p>
<p>选择哪个进程运行是由操作系统中负责完成的，这就是<strong>调度程序</strong>（<em>scheduler</em>）。</p>
<h3 id="一、调度时机"><a href="#一、调度时机" class="headerlink" title="一、调度时机"></a>一、调度时机</h3><p>在进程的生命周期中，当进程从一个运行状态到另外一状态变化的时候，其实会触发一次调度。</p>
<p>比如，以下状态的变化都会触发操作系统的调度：</p>
<ul>
<li><em>从就绪态 -&gt; 运行态</em>：当进程被创建时，会进入到就绪队列，操作系统会从就绪队列选择一个进程运行；</li>
<li><em>从运行态 -&gt; 阻塞态</em>：当进程发生 I&#x2F;O 事件而阻塞时，操作系统必须选择另外一个进程运行；</li>
<li><em>从运行态 -&gt; 结束态</em>：当进程退出结束后，操作系统得从就绪队列选择另外一个进程运行；</li>
</ul>
<p>因为，这些状态变化的时候，操作系统需要考虑是否要让新的进程给 CPU 运行，或者是否让当前进程从 CPU 上退出来而换另一个进程运行。</p>
<p>调度算法类别</p>
<ul>
<li><strong>非抢占式调度算法</strong>挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情。</li>
<li><strong>抢占式调度算法</strong>挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生<strong>时钟中断</strong>，以便把 CPU 控制返回给调度程序进行调度，也就是常说的<strong>时间片机制</strong>。</li>
</ul>
<h3 id="二、调度原则"><a href="#二、调度原则" class="headerlink" title="二、调度原则"></a>二、调度原则</h3><p>原则一：如果运行的程序，发生了 I&#x2F;O 事件的请求，那 CPU 使用率必然会很低，因为此时进程在阻塞等待硬盘的数据返回。这样的过程，势必会造成 CPU 突然的空闲。所以，<strong>为了提高 CPU 利用率，在这种发送 I&#x2F;O 事件致使 CPU 空闲的情况下，调度程序需要从就绪队列中选择一个进程来运行。</strong></p>
<p>原则二：有的程序执行某个任务花费的时间会比较长，如果这个程序一直占用着 CPU，会造成系统吞吐量（CPU 在单位时间内完成的进程数量）的降低。所以，<strong>要提高系统的吞吐率，调度程序要权衡长任务和短任务进程的运行完成数量。</strong></p>
<p>原则三：从进程开始到结束的过程中，实际上是包含两个时间，分别是进程运行时间和进程等待时间，这两个时间总和就称为周转时间。进程的周转时间越小越好，<strong>如果进程的等待时间很长而运行时间很短，那周转时间就很长，这不是我们所期望的，调度程序应该避免这种情况发生。</strong></p>
<p>原则四：处于就绪队列的进程，也不能等太久，当然希望这个等待的时间越短越好，这样可以使得进程更快的在 CPU 中执行。所以，<strong>就绪队列中进程的等待时间也是调度程序所需要考虑的原则。</strong></p>
<p>原则五：对于鼠标、键盘这种交互式比较强的应用，我们当然希望它的响应时间越快越好，否则就会影响用户体验了。所以，<strong>对于交互式比较强的应用，响应时间也是调度程序需要考虑的原则。</strong></p>
<h3 id="三、调度算法"><a href="#三、调度算法" class="headerlink" title="三、调度算法"></a>三、调度算法</h3><ul>
<li><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>时间片轮转调度算法</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li>
<li><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>
<li><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/default-index/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/default-index/">1</a><span class="page-number current">2</span><a class="page-number" href="/default-index/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/default-index/page/5/">5</a><a class="extend next" rel="next" href="/default-index/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">hnwu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hnwu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
