<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="hnwu">
<meta property="og:url" content="http://example.com/default-index/page/2/index.html">
<meta property="og:site_name" content="hnwu">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="hnwu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/default-index/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>hnwu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hnwu</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/30/%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/30/%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8/" class="post-title-link" itemprop="url">拦截器和过滤器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-30 20:58:25" itemprop="dateCreated datePublished" datetime="2022-08-30T20:58:25+08:00">2022-08-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="拦截器和过滤器"><a href="#拦截器和过滤器" class="headerlink" title="拦截器和过滤器"></a>拦截器和过滤器</h2><h4 id="一、过滤器"><a href="#一、过滤器" class="headerlink" title="一、过滤器"></a>一、过滤器</h4><p><strong>过滤器的应用场景</strong>：跨域问题解决，编码转换</p>
<p>过滤器Filter基于Servlet实现，将传入的request和response提前过滤掉一些信息或者提前设置一些参数，再对传入Servlet或Struts2中的action进行业务逻辑处理。</p>
<p>比如过滤掉非法url（不是login.do的地址请求，如果用户没有登陆都过滤掉），或者在传入Servlet或Struts2的action前统一设置字符集，或者去除掉一些非法字符。</p>
<p>Filter过滤器随着web应用的启动而启动，只初始化一次。</p>
<h4 id="二、拦截器"><a href="#二、拦截器" class="headerlink" title="二、拦截器"></a>二、拦截器</h4><p><strong>拦截器的应用场景</strong>：权限控制，日志打印，参数校验</p>
<p>拦截器是SpringMVC中实现的一种基于Java反射（动态代理）机制的方法增强工具，拦截器的实现是继承HandlerInterceptor 接口，并实现接口的preHandle、postHandle和afterCompletion方法。</p>
<p>preHandle：请求方法前置拦截，该方法会在Controller处理之前进行调用，Spring中可以有多个Interceptor，这些拦截器会按照设定的Order顺序调用，当有一个拦截器在preHandle中返回false的时候，请求就会终止。</p>
<p>postHandle：若preHandle返回结果为true时，在Controller方法执行之后，视图渲染之前被调用</p>
<p>afterCompletion：若preHandle返回true，并且整个请求结束之后，执行该方法。</p>
<h4 id="三、拦截器和过滤器之间的区别"><a href="#三、拦截器和过滤器之间的区别" class="headerlink" title="三、拦截器和过滤器之间的区别"></a>三、拦截器和过滤器之间的区别</h4><p>①拦截器基于java反射，过滤器属于Servlet级别<br>②拦截器不依赖于servlet容器，而过滤器依赖于servlet容器。<br>③拦截器只对action请求起作用，而过滤器则可以对几乎所有的请求起作用。<br>④拦截器可以访问action上下文、值、栈里面的对象，而过滤器不可以。<br>⑤在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。<br>⑥拦截器可以获取IOC容器中的各个bean，而过滤器不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</p>
<h4 id="四、拦截器与过滤器执行流程"><a href="#四、拦截器与过滤器执行流程" class="headerlink" title="四、拦截器与过滤器执行流程"></a>四、拦截器与过滤器执行流程</h4><p><img src="https://img-blog.csdnimg.cn/20190620230108441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDUwMjgwNA==,size_16,color_FFFFFF,t_70"></p>
<p><img src="https://img-blog.csdnimg.cn/20190620230043280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDUwMjgwNA==,size_16,color_FFFFFF,t_70"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/30/Explain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/30/Explain/" class="post-title-link" itemprop="url">Explain</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-30 20:50:44" itemprop="dateCreated datePublished" datetime="2022-08-30T20:50:44+08:00">2022-08-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h2><table>
<thead>
<tr>
<th align="left">列明</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">select_type</td>
<td align="left">表示select查询类型，如普通查询、联合查询、子查询</td>
</tr>
<tr>
<td align="left">type</td>
<td align="left">本次查询表联接类型，从这里可以看到本次查询大概的效率。</td>
</tr>
<tr>
<td align="left">key</td>
<td align="left">最终选择的索引，如果没有索引的话，本次查询效率通常很差。</td>
</tr>
<tr>
<td align="left">key_len</td>
<td align="left">本次查询用于结果过滤的索引实际长度。</td>
</tr>
<tr>
<td align="left">rows</td>
<td align="left">预计需要扫描的记录数，预计需要扫描的记录数越小越好。</td>
</tr>
<tr>
<td align="left">Extra</td>
<td align="left">额外附加信息，主要确认是否出现 Using filesort、Using temporary 这两种情况。</td>
</tr>
</tbody></table>
<p>其中，type包含以下几种结果，从上之下依次是最差到最好：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ALL</td>
<td align="left">执行full table scan，这是最差的一种方式。</td>
</tr>
<tr>
<td align="left">index</td>
<td align="left">执行full index scan，并且可以通过索引完成结果扫描并且直接从索引中取的想要的结果数据，也就是可以避免回表，比ALL略好，因为索引文件通常比全部数据要来的小。</td>
</tr>
<tr>
<td align="left">range</td>
<td align="left">利用索引进行范围查询，比index略好。</td>
</tr>
<tr>
<td align="left">index_subquery</td>
<td align="left">子查询中可以用到索引。</td>
</tr>
<tr>
<td align="left">unique_subquery</td>
<td align="left">子查询中可以用到唯一索引，效率比 index_subquery 更高些。</td>
</tr>
<tr>
<td align="left">index_merge</td>
<td align="left">可以利用index merge特性用到多个索引，提高查询效率。</td>
</tr>
<tr>
<td align="left">ref_or_null</td>
<td align="left">表连接类型是ref，但进行扫描的索引列中可能包含NULL值。</td>
</tr>
<tr>
<td align="left">fulltext</td>
<td align="left">全文检索。</td>
</tr>
<tr>
<td align="left">ref</td>
<td align="left">基于索引的等值查询，或者表间等值连接。</td>
</tr>
<tr>
<td align="left">eq_ref</td>
<td align="left">表连接时基于主键或非NULL的唯一索引完成扫描，比ref略好。</td>
</tr>
<tr>
<td align="left">const</td>
<td align="left">基于主键或唯一索引唯一值查询，最多返回一条结果，比eq_ref略好。</td>
</tr>
<tr>
<td align="left">system</td>
<td align="left">查询对象表只有一行数据，这是最好的情况。</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/20/Http%E7%8A%B6%E6%80%81%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/20/Http%E7%8A%B6%E6%80%81%E7%A0%81/" class="post-title-link" itemprop="url">Http状态码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-20 19:32:32 / 修改时间：19:33:10" itemprop="dateCreated datePublished" datetime="2022-08-20T19:32:32+08:00">2022-08-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-（信息提示）"><a href="#1-（信息提示）" class="headerlink" title="1**（信息提示）"></a>1**（信息提示）</h2><p>100 - Continue 初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新）<br>101 - Switching Protocols 服务器将遵从客户的请求转换到另外一种协议（HTTP 1.1新）</p>
<h2 id="2-开头-（请求成功）表示成功处理了请求的状态代码。"><a href="#2-开头-（请求成功）表示成功处理了请求的状态代码。" class="headerlink" title="2**开头 （请求成功）表示成功处理了请求的状态代码。"></a>2**开头 （请求成功）表示成功处理了请求的状态代码。</h2><p>200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。<br>201 （已创建） 请求成功并且服务器创建了新的资源。<br>202 （已接受） 服务器已接受请求，但尚未处理。<br>203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。<br>204 （无内容） 服务器成功处理了请求，但没有返回任何内容。<br>205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。<br>206 （部分内容） 服务器成功处理了部分 GET 请求。</p>
<h2 id="3-开头-（请求被重定向）表示要完成请求，需要进一步操作。-通常，这些状态代码用来重定向。"><a href="#3-开头-（请求被重定向）表示要完成请求，需要进一步操作。-通常，这些状态代码用来重定向。" class="headerlink" title="3** 开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。"></a>3** 开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</h2><p>300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br>301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。<br>302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。<br>304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。<br>305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。<br>307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p>
<h2 id="4-开头-（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。"><a href="#4-开头-（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。" class="headerlink" title="4**开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。"></a>4**开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。</h2><p>400 （错误请求） 服务器不理解请求的语法。<br>401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>403 （禁止） 服务器拒绝请求。<br>404 （未找到） 服务器找不到请求的网页。<br>405 （方法禁用） 禁用请求中指定的方法。<br>406 （不接受） 无法使用请求的内容特性响应请求的网页。<br>407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。<br>408 （请求超时） 服务器等候请求时发生超时。<br>409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。<br>410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。<br>411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。<br>412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。<br>413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。<br>415 （不支持的媒体类型） 请求的格式不受请求页面的支持。<br>416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。<br>417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。</p>
<h2 id="5-开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。-这些错误可能是服务器本身的错误，而不是请求出错。"><a href="#5-开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。-这些错误可能是服务器本身的错误，而不是请求出错。" class="headerlink" title="5**开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。"></a>5**开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</h2><p>500 （服务器内部错误） 服务器遇到错误，无法完成请求。<br>501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br>502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br>503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。<br>504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/20/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/20/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">SpringBoot自动装配原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-20 11:04:28 / 修改时间：11:05:22" itemprop="dateCreated datePublished" datetime="2022-08-20T11:04:28+08:00">2022-08-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="SpringBoot自动装配原理"><a href="#SpringBoot自动装配原理" class="headerlink" title="SpringBoot自动装配原理"></a>SpringBoot自动装配原理</h2><p>自动装配依托@Import的强大功能和Spring的SPI机制，通过SPI机制发现类，通过@Import将类注册到Spring中。</p>
<h5 id="一、自动装配的过程"><a href="#一、自动装配的过程" class="headerlink" title="一、自动装配的过程"></a>一、自动装配的过程</h5><ol>
<li>Spring Boot通过@EnableAutoConfiguration注解开启自动配置,加载spring.factories中注册的各种AutoConfiguration类</li>
<li>当某个AutoConfiguration类满足其注解@Conditional指定的生效条件（Starters提供的依赖、配置或Spring容器中是否存在某个Bean等）时,实例化该AutoConfiguration类中定义的Bean（组件等）,并注入Spring容器,就可以完成依赖框架的自动配置。 </li>
<li>这些AutoConfiguration类的原理就是通过@Import注解将其属性类properties全部注册到spring容器中，属性类通过注解@ConfigurationProperties从配置文件里面取到配置值，之后将关键的类注册为bean自动注入属性类进行初始化，完成自动装配的功能</li>
</ol>
<h5 id="二、-EnableAutoConfiguration-作用"><a href="#二、-EnableAutoConfiguration-作用" class="headerlink" title="二、@EnableAutoConfiguration 作用"></a>二、@EnableAutoConfiguration 作用</h5><p>寻找每个jar里面的META-INF&#x2F;spring-factories文件，然后将文件中的类全部实例化</p>
<h5 id="三、-EnableAutoConfiguration-原理"><a href="#三、-EnableAutoConfiguration-原理" class="headerlink" title="三、@EnableAutoConfiguration 原理"></a>三、@EnableAutoConfiguration 原理</h5><ol>
<li>ImportSelector 该接口的方法的返回值都会被纳入到spring容器管理中 </li>
<li>SpringFactoriesLoader类可以从classpath中搜索所有META-INF&#x2F;spring.factories配置文件,并读取配置</li>
</ol>
<h5 id="四、SpringFactoriesLoader实现原理"><a href="#四、SpringFactoriesLoader实现原理" class="headerlink" title="四、SpringFactoriesLoader实现原理"></a>四、SpringFactoriesLoader实现原理</h5><p><strong>SpringFactoriesLoader这个工具类</strong> 和 <code>JDK</code>的 <code>SPI</code>原理一样，不过它比 SPI 更好的点在于不会一次性加载所有的类，而是根据 key 进行加载。SpringFactoriesLoader 的 作 用 是 从classpath&#x2F;META-INF&#x2F;spring.factories 文件中，根据 key 来加载对应的类到 spring IoC 容器中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fcb-it/p/12905525.html">https://www.cnblogs.com/fcb-it/p/12905525.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/16/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/16/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/" class="post-title-link" itemprop="url">Redis持久化策略</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-16 11:34:32 / 修改时间：11:36:00" itemprop="dateCreated datePublished" datetime="2022-08-16T11:34:32+08:00">2022-08-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Redis-持久化策略"><a href="#Redis-持久化策略" class="headerlink" title="Redis 持久化策略"></a>Redis 持久化策略</h2><p>Redis4.0之后,Redis有RDB持久化、AOF持久化、RDB-AOF混合持久化这三种持久化方式。 </p>
<h4 id="一、RDB策略"><a href="#一、RDB策略" class="headerlink" title="一、RDB策略"></a>一、RDB策略</h4><p>RDB持久化是**将当前进程数据以生成快照的方式保存到硬盘的过程,**也是Redis默认的持久化机制。RDB会创建一个经过压缩的二进制文件,这个文件以’.rdb‘结尾,内部存储了各个数据库的键值对等信息。</p>
<h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><p>RDB持久化主要是通过SAVE和BGSAVE两个命令对Redis数据库中当前的数据做snapshot并生成rdb文件来实现的。</p>
<p><strong>save 命令</strong>会一直阻塞当前Redis服务器到RBD过程完成为止,所以这种方式在操作内存比较大的实例时会造成长时间阻塞,因此线上环境不建议使用,该命令已经被废弃。</p>
<p><strong>gsave命令</strong>会让Redis进程执行fork创建子进程,由子进程负责RBD持久化过程,完成后自动结束,因此只在fork阶段发生阻塞,一般阻塞的时间也不会很长。因此Redis内部所涉及的几乎所有RDB操作都采用了bgsave的方式。</p>
<p>在Redis启动的时候会检测rdb文件，然后载入rdb文件中未过期的数据到服务器中</p>
<p>在指定的时间间隔内将内存中的数据集快照写入内存， 也就是行话讲的Snapshot快照，他恢复时是将快照文件直接读到内存中。</p>
<p>Redis会单独创建一个子进程来持节话，会先将数据写入到一个临时文件中，待持久化过程都结束了。再用这个临时文件替换上次持久化好的文件。整个过程中，主进程都不参与IO操作，这就极高的提升了性能。</p>
<h5 id="（一）优点"><a href="#（一）优点" class="headerlink" title="（一）优点"></a>（一）优点</h5><p>其生成的紧凑压缩的二进制文件体积小,使用该文件恢复数据的速度非常快</p>
<h5 id="（二）缺点"><a href="#（二）缺点" class="headerlink" title="（二）缺点"></a>（二）缺点</h5><p>BGSAVE每次运行都要执行fork操作创建子进程,这属于重量级操作,不宜频繁执行,因此,RBD没法做到实时的持久化。 </p>
<h4 id="二、AOF策略"><a href="#二、AOF策略" class="headerlink" title="二、AOF策略"></a>二、AOF策略</h4><p>Redis 默认不开启。它的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个<strong>写操作</strong>，并<strong>追加</strong>到文件中。Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
<h5 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h5><p>AOF（Append Only File）持久化是通过将存储每次执行的客户端命令，然后由一个伪客户端来执行这些命令将数据写入到服务器中的方式实现的。一共分为<code>命令追加</code>、<code>文件写入</code>、<code>文件同步</code>三个步骤完成的</p>
<p><strong>命令追加</strong>：当有修改、删除操作时，服务器会在执行完之后以协议格式将被执行的写命令追加到服务器状态的<code>aof_buf</code>缓冲区的末尾</p>
<p><strong>文件写入</strong>：Redis的服务进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求。服务器在处理文件事件时可能会执行写命令，同时会追加到<code>aof_buf</code>缓冲区，所以在每结束一次循环之前，都会调用<code>flushAppendOnlyFile</code>函数，将<code>aof_buf</code>缓冲区的数据写入到AOF文件里面。</p>
<p><strong>文件同步</strong>：<code>flushAppendOnlyFile</code>函数通过服务器配置<code>appendfsync</code>选项的值来决定的将每次循环结束之前<code>aof_buf</code>缓冲区的数据写入到AOF文件后，将以何种方式同步到AOF文件里面：</p>
<h5 id="（一）优点-1"><a href="#（一）优点-1" class="headerlink" title="（一）优点"></a>（一）优点</h5><p>与RDB持久化可能丢失大量的数据相比,AOF持久化的安全性要高很多。通过使用everysec选项,用户可以将数据丢失的时间窗口限制在1秒之内。</p>
<h5 id="（二）缺点-1"><a href="#（二）缺点-1" class="headerlink" title="（二）缺点"></a>（二）缺点</h5><ol>
<li>AOF文件存储的是协议文本,它的体积要比二进制格式的”.rdb”文件大很多。</li>
<li>AOF需要通过执行AOF文件中的命令来恢复数据库,其恢复速度比RDB慢很多。</li>
<li>AOF在进行重写时也需要创建子进程,在数据库体积较大时将占用大量资源,会导致服务器的短暂阻塞。</li>
</ol>
<p>AOF解决了数据持久化的实时性,是目前Redis主流的持久化方式。</p>
<h4 id="三、RDB-AOF混合持久化策略"><a href="#三、RDB-AOF混合持久化策略" class="headerlink" title="三、RDB-AOF混合持久化策略"></a>三、RDB-AOF混合持久化策略</h4><p>RDB-AOF混合持久化模式是Redis4.0开始引入的,这种模式是基于AOF持久化构建而来的。用户可以通过配置文件中的“aof-use-rdb-preamble yes”配置项开启AOF混合持久化。</p>
<p>Redis服务器在执行AOF重写操作时,会像执行BGSAVE命令一样,根据数据库当前的状态生成相应的RDB数据,并将其写入AOF文件中；对于重写之后执行的Redis命令,则以协议文本的方式追加到AOF文件的末尾,即RDB数据之后。 </p>
<p>通过使用RDB-AOF混合持久化,用户可以同时获得RDB持久化和AOF持久化的优点</p>
<ol>
<li>通过AOF文件包含的RDB数据来实现快速的数据恢复操作</li>
<li>通过AOF文件包含的AOF数据来将丢失数据的时间窗口限制在1s之内</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/15/%E5%8D%8F%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/15/%E5%8D%8F%E7%A8%8B/" class="post-title-link" itemprop="url">协程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-15 11:52:18 / 修改时间：11:52:51" itemprop="dateCreated datePublished" datetime="2022-08-15T11:52:18+08:00">2022-08-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h4 id="一、什么是协程"><a href="#一、什么是协程" class="headerlink" title="一、什么是协程"></a>一、什么是协程</h4><p>​	协程是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程也被叫做<strong>用户空间线程</strong>，具有<strong>内核不可见的特性</strong>。</p>
<p>​	因为是自主开辟的异步任务，所以很多人也更喜欢叫它们纤程（Fiber），或者绿色线程（GreenThread）。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p>
<h4 id="二、协程的作用"><a href="#二、协程的作用" class="headerlink" title="二、协程的作用"></a>二、协程的作用</h4><p>在传统的J2EE系统中都是基于每个请求占用一个线程去完成完整的业务逻辑（包括事务）。所以系统的吞吐能力取决于每个线程的操作耗时。如果遇到很耗时的I&#x2F;O行为，则整个系统的吞吐立刻下降，因为这个时候线程一直处于阻塞状态，如果线程很多的时候，会存在很多线程处于空闲状态（等待该线程执行完才能执行），造成了资源应用不彻底。</p>
<p>最常见的例子就是JDBC（它是同步阻塞的），这也是为什么很多人都[数据库是瓶颈的原因。这里的耗时其实是让CPU一直在等待I&#x2F;O返回，说白了线程根本没有利用CPU去做运算，而是处于空转状态。而另外过多的线程，也会带来更多的上下文开销。</p>
<p>协程的目的就是<strong>当出现长时间的I&#x2F;O操作时，通过让出目前的协程调度，执行下一个任务的方式，来消除上下文上的开销。</strong></p>
<h4 id="三、协程的特点"><a href="#三、协程的特点" class="headerlink" title="三、协程的特点"></a>三、协程的特点</h4><ol>
<li>线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率。</li>
<li>线程的默认Stack大小是1M，而协程更轻量，接近2K。因此可以在相同的内存中开启更多的协程。</li>
<li>由于在同一个线程上，因此可以避免竞争关系而使用锁。</li>
<li>适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程，遇到此种情况，更好实用线程去解决。</li>
</ol>
<h4 id="四、协程的原理"><a href="#四、协程的原理" class="headerlink" title="四、协程的原理"></a>四、协程的原理</h4><p>当出现IO阻塞的时候，由协程的调度器进行调度，通过将数据流立刻yield掉（主动让出），并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复栈，并把阻塞的结果放到这个线程上去跑，这样看上去好像跟写同步代码没有任何差别，这整个流程可以称为coroutine，而跑在由<code>coroutine</code>负责调度的线程称为<code>Fiber</code>。</p>
<p><strong>由于协程的暂停完全由程序控制，发生在用户态上；而线程的阻塞状态是由操作系统内核来进行切换，发生在内核态上。 因此，协程的开销远远小于线程的开销，也就减少了上下文的开销。</strong></p>
<h4 id="五、线程与线程比较"><a href="#五、线程与线程比较" class="headerlink" title="五、线程与线程比较"></a>五、线程与线程比较</h4><table>
<thead>
<tr>
<th></th>
<th>线程</th>
<th>协程</th>
</tr>
</thead>
<tbody><tr>
<td>占有资源</td>
<td>初始单位为1MB,固定不可变</td>
<td>初始一般为 2KB，可随需要而增大</td>
</tr>
<tr>
<td>调度所属</td>
<td>由操作系统内核完成</td>
<td>由用户自定义完成</td>
</tr>
<tr>
<td>切换开销</td>
<td>线程的私有数据、寄存器、硬件上下文</td>
<td>只有三个寄存器的值修改 - PC &#x2F; SP &#x2F; DX.</td>
</tr>
<tr>
<td>性能问题</td>
<td>资源占用高，频繁创建销毁导致性能降低</td>
<td>资源占用小,不会带来严重的性能问题</td>
</tr>
<tr>
<td>数据同步</td>
<td>需要用锁等机制确保数据的一直性和可见性</td>
<td>只有一个线程，因此不需要锁机制，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/14/%E8%B0%83%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/14/%E8%B0%83%E5%BA%A6/" class="post-title-link" itemprop="url">调度</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-14 16:06:03 / 修改时间：16:06:34" itemprop="dateCreated datePublished" datetime="2022-08-14T16:06:03+08:00">2022-08-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>一旦操作系统把进程切换到运行状态，也就意味着该进程占用着 CPU 在执行，但是当操作系统把进程切换到其他状态时，那就不能在 CPU 中执行了，于是操作系统会选择下一个要运行的进程。</p>
<p>选择哪个进程运行是由操作系统中负责完成的，这就是<strong>调度程序</strong>（<em>scheduler</em>）。</p>
<h3 id="一、调度时机"><a href="#一、调度时机" class="headerlink" title="一、调度时机"></a>一、调度时机</h3><p>在进程的生命周期中，当进程从一个运行状态到另外一状态变化的时候，其实会触发一次调度。</p>
<p>比如，以下状态的变化都会触发操作系统的调度：</p>
<ul>
<li><em>从就绪态 -&gt; 运行态</em>：当进程被创建时，会进入到就绪队列，操作系统会从就绪队列选择一个进程运行；</li>
<li><em>从运行态 -&gt; 阻塞态</em>：当进程发生 I&#x2F;O 事件而阻塞时，操作系统必须选择另外一个进程运行；</li>
<li><em>从运行态 -&gt; 结束态</em>：当进程退出结束后，操作系统得从就绪队列选择另外一个进程运行；</li>
</ul>
<p>因为，这些状态变化的时候，操作系统需要考虑是否要让新的进程给 CPU 运行，或者是否让当前进程从 CPU 上退出来而换另一个进程运行。</p>
<p>调度算法类别</p>
<ul>
<li><strong>非抢占式调度算法</strong>挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情。</li>
<li><strong>抢占式调度算法</strong>挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生<strong>时钟中断</strong>，以便把 CPU 控制返回给调度程序进行调度，也就是常说的<strong>时间片机制</strong>。</li>
</ul>
<h3 id="二、调度原则"><a href="#二、调度原则" class="headerlink" title="二、调度原则"></a>二、调度原则</h3><p>原则一：如果运行的程序，发生了 I&#x2F;O 事件的请求，那 CPU 使用率必然会很低，因为此时进程在阻塞等待硬盘的数据返回。这样的过程，势必会造成 CPU 突然的空闲。所以，<strong>为了提高 CPU 利用率，在这种发送 I&#x2F;O 事件致使 CPU 空闲的情况下，调度程序需要从就绪队列中选择一个进程来运行。</strong></p>
<p>原则二：有的程序执行某个任务花费的时间会比较长，如果这个程序一直占用着 CPU，会造成系统吞吐量（CPU 在单位时间内完成的进程数量）的降低。所以，<strong>要提高系统的吞吐率，调度程序要权衡长任务和短任务进程的运行完成数量。</strong></p>
<p>原则三：从进程开始到结束的过程中，实际上是包含两个时间，分别是进程运行时间和进程等待时间，这两个时间总和就称为周转时间。进程的周转时间越小越好，<strong>如果进程的等待时间很长而运行时间很短，那周转时间就很长，这不是我们所期望的，调度程序应该避免这种情况发生。</strong></p>
<p>原则四：处于就绪队列的进程，也不能等太久，当然希望这个等待的时间越短越好，这样可以使得进程更快的在 CPU 中执行。所以，<strong>就绪队列中进程的等待时间也是调度程序所需要考虑的原则。</strong></p>
<p>原则五：对于鼠标、键盘这种交互式比较强的应用，我们当然希望它的响应时间越快越好，否则就会影响用户体验了。所以，<strong>对于交互式比较强的应用，响应时间也是调度程序需要考虑的原则。</strong></p>
<h3 id="三、调度算法"><a href="#三、调度算法" class="headerlink" title="三、调度算法"></a>三、调度算法</h3><ul>
<li><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>时间片轮转调度算法</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li>
<li><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>
<li><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/14/%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/14/%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-14 16:06:03" itemprop="dateCreated datePublished" datetime="2022-08-14T16:06:03+08:00">2022-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-12 14:42:19" itemprop="dateModified" datetime="2023-01-12T14:42:19+08:00">2023-01-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/14/%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/14/%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">线程管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-14 13:51:12 / 修改时间：13:52:11" itemprop="dateCreated datePublished" datetime="2022-08-14T13:51:12+08:00">2022-08-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><h3 id="一、什么是线程"><a href="#一、什么是线程" class="headerlink" title="一、什么是线程"></a>一、什么是线程</h3><p>线程，有时候被称为轻量级进程，是程序执行流的最小单元</p>
<p>一个标准的线程由线程ID、当前指令指针(PC)、寄存器集合和堆栈组成</p>
<p>同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。</p>
<h5 id="线程的优点："><a href="#线程的优点：" class="headerlink" title="线程的优点："></a>线程的优点：</h5><ul>
<li>一个进程中可以同时存在多个线程；</li>
<li>各个线程之间可以并发执行；</li>
<li>各个线程之间可以共享地址空间和文件等资源；</li>
</ul>
<h5 id="线程的缺点："><a href="#线程的缺点：" class="headerlink" title="线程的缺点："></a>线程的缺点：</h5><ul>
<li>当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（JVM中线程奔溃不会造成进程崩溃,<strong>因为 JVM 自定义了自己的信号处理函数，拦截了 SIGSEGV 信号</strong>)</li>
<li>多线程上下文切换消耗资源</li>
</ul>
<h3 id="二、线程与进程的比较"><a href="#二、线程与进程的比较" class="headerlink" title="二、线程与进程的比较"></a>二、线程与进程的比较</h3><h5 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h5><ul>
<li>进程是资源（包括内存、打开的文件等）分配的基本单位，线程是 CPU 调度的基本单位；</li>
<li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</li>
<li>线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</li>
<li>一个线程挂掉，对应的进程挂掉；一个进程挂掉，不会影响其他进程</li>
<li>进程在执行时拥有独立的内存单元，多个线程共享进程的内存，如代码段、数据段、扩展段；但每个线程拥有自己的栈段和寄存器组</li>
<li>进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈，线程切换时只需要切换硬件上下文和内核栈</li>
<li>进程之间通信和线程之间通信方式不一样</li>
</ul>
<h5 id="相较于进程，线程的优势"><a href="#相较于进程，线程的优势" class="headerlink" title="相较于进程，线程的优势"></a>相较于进程，线程的优势</h5><ul>
<li>线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；</li>
<li>线程的终止时间比进程快，因为线程释放的资源相比进程少很多；</li>
<li>同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；</li>
<li>由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；</li>
</ul>
<h3 id="三、线程的上下文切换"><a href="#三、线程的上下文切换" class="headerlink" title="三、线程的上下文切换"></a>三、线程的上下文切换</h3><h5 id="情况一：当两个线程不是属于同一个进程"><a href="#情况一：当两个线程不是属于同一个进程" class="headerlink" title="情况一：当两个线程不是属于同一个进程"></a>情况一：当两个线程不是属于同一个进程</h5><p>切换的过程就跟进程上下文切换一样</p>
<h5 id="情况二：当两个线程是属于同一个进程"><a href="#情况二：当两个线程是属于同一个进程" class="headerlink" title="情况二：当两个线程是属于同一个进程"></a>情况二：当两个线程是属于同一个进程</h5><p>因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据以及硬件上下文</p>
<p>因此线程的上下文切换相比进程，开销要小很多</p>
<h3 id="四、线程的实现"><a href="#四、线程的实现" class="headerlink" title="四、线程的实现"></a>四、线程的实现</h3><h4 id="（一）用户线程（User-Thread）"><a href="#（一）用户线程（User-Thread）" class="headerlink" title="（一）用户线程（User Thread）"></a>（一）用户线程（User Thread）</h4><p>用户线程是基于用户态的线程管理库来实现的，那么<strong>线程控制块（Thread Control Block, TCB）</strong> 也是在库里面来实现的，对于操作系统而言是看不到这个 TCB 的，它只能看到整个进程的 PCB。</p>
<p>因此用户线程的整个线程管理和调度，<strong>操作系统是不直接参与的</strong>，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。</p>
<h5 id="用户线程的优点："><a href="#用户线程的优点：" class="headerlink" title="用户线程的优点："></a>用户线程的<strong>优点</strong>：</h5><ul>
<li>每个进程都需要有它私有的线程控制块（TCB）列表，用来跟踪记录它各个线程状态信息（PC、栈指针、寄存器），TCB 由用户级线程库函数来维护，可用于不支持线程技术的操作系统；</li>
<li>用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换，所以速度特别快；</li>
</ul>
<h5 id="用户线程的缺点："><a href="#用户线程的缺点：" class="headerlink" title="用户线程的缺点："></a>用户线程的<strong>缺点</strong>：</h5><ul>
<li>由于操作系统不参与线程的调度，如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了。</li>
<li>当一个线程开始运行后，除非它主动地交出 CPU 的使用权，否则它所在的进程当中的其他线程无法运行，因为用户态的线程没法打断当前运行中的线程，它没有这个特权，只有操作系统才有，但是用户线程不是由操作系统管理的。</li>
<li>由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会比较慢；</li>
</ul>
<h4 id="（二）内核线程（Kernel-Thread）"><a href="#（二）内核线程（Kernel-Thread）" class="headerlink" title="（二）内核线程（Kernel Thread）"></a>（二）内核线程（Kernel Thread）</h4><p>内核线程是由操作系统管理的，线程对应的 TCB 自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。</p>
<h5 id="内核线程的优点："><a href="#内核线程的优点：" class="headerlink" title="内核线程的优点："></a>内核线程的<strong>优点</strong>：</h5><ul>
<li>在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；</li>
<li>分配给线程，多线程的进程获得更多的 CPU 运行时间；</li>
</ul>
<h5 id="内核线程的缺点："><a href="#内核线程的缺点：" class="headerlink" title="内核线程的缺点："></a>内核线程的<strong>缺点</strong>：</h5><ul>
<li>在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB；</li>
<li>线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大；</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/13/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/13/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" class="post-title-link" itemprop="url">分布式事务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-13 12:03:59 / 修改时间：12:05:37" itemprop="dateCreated datePublished" datetime="2022-08-13T12:03:59+08:00">2022-08-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><pre><code>分布式事务就是指**事务的发起者、资源及资源管理器和事务协调者分别位于分布式系统的不同节点中**。银行跨行转账业务是一个典型分布式事务场景，假设A需要跨行转账给B，那么就涉及两个银行的数据，无法通过一个数据库的本地事务保证转账的ACID，只能够通过分布式事务来解决。
</code></pre>
<p>分布式事务<strong>部分遵循</strong> ACID 规范：</p>
<ul>
<li>原子性 &amp;&amp; 持久性：严格遵循</li>
<li>一致性：事务过程不一致，事务完成最终一致</li>
<li>隔离性：并行事务间不可影响；事务中间结果可见性允许安全放宽</li>
</ul>
<p>PS：分布式事务满足CAP的C，但是不满足ACID的C，也被称为最终一致、</p>
<h3 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h3><p>AT：非侵入式，容易开发，禁止使用XA事务的场景适用</p>
<p>XA：非侵入式，容易开发，但对资源长时间锁定，并发度低</p>
<p>SAGA：长事务适用，对中间结果不敏感的业务场景适用</p>
<p>TCC：适用于订单类业务，对中间状态有约束的业务</p>
<ul>
<li>RM 资源管理器，是业务服务，负责本地数据库的管理</li>
<li>TM 事务管理器，负责全局事务的状态管理，负责协调各个事务分支的执行</li>
<li>APP 应用程序，是业务服务，负责全局事务的发起</li>
</ul>
<h4 id="一、AT事务模式"><a href="#一、AT事务模式" class="headerlink" title="一、AT事务模式"></a>一、AT事务模式</h4><h5 id="（一）前提"><a href="#（一）前提" class="headerlink" title="（一）前提"></a>（一）前提</h5><ul>
<li>基于支持本地 ACID 事务的关系型数据库。</li>
<li>Java 应用，通过 JDBC 访问数据库</li>
</ul>
<h5 id="（二）工作机制"><a href="#（二）工作机制" class="headerlink" title="（二）工作机制"></a>（二）工作机制</h5><h5 id="一阶段："><a href="#一阶段：" class="headerlink" title="一阶段："></a><strong>一阶段：</strong></h5><ol>
<li>RM 侧，用户开启本地事务</li>
<li>RM 侧，用户每进行一次业务数据修改，假设是一个update语句，那么 AT 会做以下内容：<ol>
<li>根据update的条件，查询出修改前的数据，该数据称为BeforeImage</li>
<li>执行update语句，根据BeforeImage中的主键，查询出修改后的数据，该数据称为AfterImage</li>
<li>将BeforeImage和AfterImage保存到一张undolog表</li>
<li>将BeforeImage中的主键以及表名，该数据称为lockKey，记录下来，留待后续使用</li>
</ol>
</li>
<li>RM 侧，用户提交本地事务时，AT 会做以下内容：<ol>
<li>将2.4中记录的所有的lockKey，注册到 TC（即事务管理器seata）上</li>
<li>3.1中的注册处理会检查 TC 中，是否已存在冲突的主键+表名，如果有冲突，那么AT会睡眠等待后重试，没有冲突则保存</li>
<li>3.1成功完成后，提交本地事务</li>
</ol>
</li>
</ol>
<h5 id="二阶段-commit"><a href="#二阶段-commit" class="headerlink" title="二阶段 commit"></a><strong>二阶段 commit</strong></h5><ol>
<li>TC 会将当前这个全局事务所有相关的lockKey删除</li>
<li>TC 通知与当前这个全局事务相关的所有业务服务，告知全局事务已成功，可以删除undolog中保存的数据</li>
<li>RM 收到通知后，删除undolog中的数据</li>
</ol>
<h5 id="二阶段-rollback"><a href="#二阶段-rollback" class="headerlink" title="二阶段 rollback"></a>二阶段 rollback</h5><ol>
<li>TC 通知与当前这个全局事务相关的所有业务服务，告知全局事务失败，执行回滚</li>
<li>RM 收到通知后，对本地数据的修改进行回滚，回滚原理如下：<ol>
<li>从undolog中取出修改前后的BeforeImage和AfterImage</li>
<li>如果AfterImage与数据库中的当前记录校验一致，那么使用BeforeImage中的数据覆盖当前记录</li>
<li>如果AfterImage与数据库中的当前记录不一致，那么这个时候发生了<strong>脏回滚</strong>，此时需要人工介入解决</li>
</ol>
</li>
<li>TC 待全局事务所有的分支，都完成了回滚，TC 将此全局事务所有的lockKey删除</li>
</ol>
<h4 id="二、XA事务模式"><a href="#二、XA事务模式" class="headerlink" title="二、XA事务模式"></a>二、XA事务模式</h4><p>XA是由X&#x2F;Open组织提出的分布式事务的规范，XA规范主要定义了(全局)事务管理器(TM)和(局部)资源管理器(RM)之间的接口。本地的数据库如mysql在XA中扮演的是RM角色，XA的缺点就在于需要锁定资源</p>
<p>XA一共分为两阶段：</p>
<p>第一阶段（prepare）：即所有的参与者RM准备执行事务<strong>并锁住需要的资源</strong>。参与者ready时，向TM报告已准备就绪。 </p>
<p>第二阶段 (commit&#x2F;rollback)：当事务管理者(TM)确认所有参与者(RM)都ready后，向所有参与者发送commit命令。</p>
<p>XA 事务由一个或多个资源管理器（RM）、一个事务管理器（TM）和一个应用程序（ApplicationProgram）组成。</p>
<p><img src="https://segmentfault.com/img/bVcTlFw"></p>
<p>如果有任何一个参与者prepare失败，那么TM会通知所有完成prepare的参与者进行回滚。</p>
<h4 id="三、SAGA"><a href="#三、SAGA" class="headerlink" title="三、SAGA"></a>三、SAGA</h4><p>​	SAGA原理是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。</p>
<p><img src="https://segmentfault.com/img/bVcTlFy"></p>
<p>Saga一旦到了Cancel阶段，那么Cancel在业务逻辑上是不允许失败了。如果因为网络或者其他临时故障，导致没有返回成功，那么TM会不断重试，直到Cancel返回成功。</p>
<p>Saga事务的特点：</p>
<ul>
<li>并发度高，不用像XA事务那样长期锁定资源</li>
<li>需要定义正常操作以及补偿操作，开发量比XA大</li>
<li>一致性较弱，对于转账，可能发生A用户已扣款，最后转账又失败的情况</li>
</ul>
<h4 id="四、TCC"><a href="#四、TCC" class="headerlink" title="四、TCC"></a>四、TCC</h4><p>TCC分为3个阶段</p>
<ul>
<li>Try 阶段：尝试执行，完成所有业务检查（一致性）, 预留必须业务资源（准隔离性）</li>
<li>Confirm 阶段：如果所有分支的Try都成功了，则走到Confirm阶段。Confirm真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源</li>
<li>Cancel 阶段：如果所有分支的Try有一个失败了，则走到Cancel阶段。Cancel释放 Try 阶段预留的业务资源。</li>
</ul>
<p><img src="https://segmentfault.com/img/bVcTlFD"></p>
<p>TCC的Confirm&#x2F;Cancel阶段在业务逻辑上是不允许返回失败的，如果因为网络或者其他临时故障，导致不能返回成功，TM会不断的重试，直到Confirm&#x2F;Cancel返回成功。</p>
<p>TCC特点如下：</p>
<ul>
<li>并发度较高，无长期资源锁定。</li>
<li>开发量较大，需要提供Try&#x2F;Confirm&#x2F;Cancel接口。</li>
<li>一致性较好，不会发生SAGA已扣款最后又转账失败的情况</li>
</ul>
<h4 id="五、二阶段消息"><a href="#五、二阶段消息" class="headerlink" title="五、二阶段消息"></a>五、二阶段消息</h4><p>dtm首创了一种二阶段消息架构，该架构大大优于本地消息表和事务消息，可以完美替代本地消息表和事务消息。</p>
<p><img src="https://segmentfault.com/img/bVcXBhX"></p>
<p>一般情况下，时序图中的5个步骤会正常完成，整个业务按照预期进行，全局事务完成。</p>
<p>这里面有个新的内容需要解释一下，就是msg的提交是按照两个阶段发起的，第一阶段调用Prepare，第二阶段调用Commit，DTM收到Prepare调用后，不会调用分支事务，而是等待后续的Submit。只有收到了Submit，开始分支调用，最终完成全局事务。</p>
<p>对比本地消息表和事务消息，二阶段消息有以下优点：</p>
<ul>
<li>不需要队列，因此不需要消费者，用户就是简单的调用API</li>
<li>二阶段消息也有回查，但是回查是框架自动处理，且保证数据正确</li>
</ul>
<h4 id="六、最大努力通知"><a href="#六、最大努力通知" class="headerlink" title="六、最大努力通知"></a>六、最大努力通知</h4><p>发起通知方通过一定的机制最大努力将业务处理结果通知到接收方。具体包括：</p>
<p>有一定的消息重复通知机制。因为接收通知方可能没有接收到通知，此时要有一定的机制对消息重复通知。 消息校对机制。如果尽最大努力也没有通知到接收方，或者接收方消费消息后要再次消费，此时可由接收方主动向通知方查询消息信息来满足需求。 前面介绍的的本地消息表和事务消息都属于可靠消息，与这里介绍的最大努力通知有什么不同？</p>
<p>可靠消息一致性，发起通知方需要保证将消息发出去，并且将消息发到接收通知方，消息的可靠性关键由发起通知方来保证。</p>
<p>最大努力通知，发起通知方尽最大的努力将业务处理结果通知为接收通知方，但是可能消息接收不到，此时需要接收通知方主动调用发起通知方的接口查询业务处理结果，通知的可靠性关键在接收通知方。</p>
<p>解决方案上，最大努力通知需要：</p>
<ul>
<li>提供接口，让被通知方能够通过接口查询业务处理结果</li>
<li>消息队列ACK机制，消息队列按照间隔1min、5min、10min、30min、1h、2h、5h、10h的方式，逐步拉大通知间隔 ，直到达到通知要求的时间窗口上限。之后不再通知</li>
</ul>
<p>最大努力通知适用于业务通知类型，例如微信交易的结果，就是通过最大努力通知方式通知各个商户，既有回调通知，也有交易查询接口</p>
<p>最大努力通知更多是业务上的设计，在基础设施层，可以直接使用二阶段消息，或者事务消息、本地消息表</p>
<p>参考链接</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000040321750">分布式事务最经典的七种解决方案</a></p>
<p><a target="_blank" rel="noopener" href="https://dtm.pub/practice/theory.html">DTM</a></p>
<p><a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">SEATA</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/default-index/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/default-index/">1</a><span class="page-number current">2</span><a class="page-number" href="/default-index/page/3/">3</a><a class="page-number" href="/default-index/page/4/">4</a><a class="extend next" rel="next" href="/default-index/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">hnwu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hnwu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
