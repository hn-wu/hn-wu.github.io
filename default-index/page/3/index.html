<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="hnwu">
<meta property="og:url" content="http://example.com/default-index/page/3/index.html">
<meta property="og:site_name" content="hnwu">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="hnwu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/default-index/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>hnwu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hnwu</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/14/%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/14/%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-14 16:06:03" itemprop="dateCreated datePublished" datetime="2022-08-14T16:06:03+08:00">2022-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-12 14:42:19" itemprop="dateModified" datetime="2023-01-12T14:42:19+08:00">2023-01-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/14/%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/14/%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">线程管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-14 13:51:12 / 修改时间：13:52:11" itemprop="dateCreated datePublished" datetime="2022-08-14T13:51:12+08:00">2022-08-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><h3 id="一、什么是线程"><a href="#一、什么是线程" class="headerlink" title="一、什么是线程"></a>一、什么是线程</h3><p>线程，有时候被称为轻量级进程，是程序执行流的最小单元</p>
<p>一个标准的线程由线程ID、当前指令指针(PC)、寄存器集合和堆栈组成</p>
<p>同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。</p>
<h5 id="线程的优点："><a href="#线程的优点：" class="headerlink" title="线程的优点："></a>线程的优点：</h5><ul>
<li>一个进程中可以同时存在多个线程；</li>
<li>各个线程之间可以并发执行；</li>
<li>各个线程之间可以共享地址空间和文件等资源；</li>
</ul>
<h5 id="线程的缺点："><a href="#线程的缺点：" class="headerlink" title="线程的缺点："></a>线程的缺点：</h5><ul>
<li>当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（JVM中线程奔溃不会造成进程崩溃,<strong>因为 JVM 自定义了自己的信号处理函数，拦截了 SIGSEGV 信号</strong>)</li>
<li>多线程上下文切换消耗资源</li>
</ul>
<h3 id="二、线程与进程的比较"><a href="#二、线程与进程的比较" class="headerlink" title="二、线程与进程的比较"></a>二、线程与进程的比较</h3><h5 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h5><ul>
<li>进程是资源（包括内存、打开的文件等）分配的基本单位，线程是 CPU 调度的基本单位；</li>
<li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</li>
<li>线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</li>
<li>一个线程挂掉，对应的进程挂掉；一个进程挂掉，不会影响其他进程</li>
<li>进程在执行时拥有独立的内存单元，多个线程共享进程的内存，如代码段、数据段、扩展段；但每个线程拥有自己的栈段和寄存器组</li>
<li>进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈，线程切换时只需要切换硬件上下文和内核栈</li>
<li>进程之间通信和线程之间通信方式不一样</li>
</ul>
<h5 id="相较于进程，线程的优势"><a href="#相较于进程，线程的优势" class="headerlink" title="相较于进程，线程的优势"></a>相较于进程，线程的优势</h5><ul>
<li>线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；</li>
<li>线程的终止时间比进程快，因为线程释放的资源相比进程少很多；</li>
<li>同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；</li>
<li>由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；</li>
</ul>
<h3 id="三、线程的上下文切换"><a href="#三、线程的上下文切换" class="headerlink" title="三、线程的上下文切换"></a>三、线程的上下文切换</h3><h5 id="情况一：当两个线程不是属于同一个进程"><a href="#情况一：当两个线程不是属于同一个进程" class="headerlink" title="情况一：当两个线程不是属于同一个进程"></a>情况一：当两个线程不是属于同一个进程</h5><p>切换的过程就跟进程上下文切换一样</p>
<h5 id="情况二：当两个线程是属于同一个进程"><a href="#情况二：当两个线程是属于同一个进程" class="headerlink" title="情况二：当两个线程是属于同一个进程"></a>情况二：当两个线程是属于同一个进程</h5><p>因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据以及硬件上下文</p>
<p>因此线程的上下文切换相比进程，开销要小很多</p>
<h3 id="四、线程的实现"><a href="#四、线程的实现" class="headerlink" title="四、线程的实现"></a>四、线程的实现</h3><h4 id="（一）用户线程（User-Thread）"><a href="#（一）用户线程（User-Thread）" class="headerlink" title="（一）用户线程（User Thread）"></a>（一）用户线程（User Thread）</h4><p>用户线程是基于用户态的线程管理库来实现的，那么<strong>线程控制块（Thread Control Block, TCB）</strong> 也是在库里面来实现的，对于操作系统而言是看不到这个 TCB 的，它只能看到整个进程的 PCB。</p>
<p>因此用户线程的整个线程管理和调度，<strong>操作系统是不直接参与的</strong>，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。</p>
<h5 id="用户线程的优点："><a href="#用户线程的优点：" class="headerlink" title="用户线程的优点："></a>用户线程的<strong>优点</strong>：</h5><ul>
<li>每个进程都需要有它私有的线程控制块（TCB）列表，用来跟踪记录它各个线程状态信息（PC、栈指针、寄存器），TCB 由用户级线程库函数来维护，可用于不支持线程技术的操作系统；</li>
<li>用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换，所以速度特别快；</li>
</ul>
<h5 id="用户线程的缺点："><a href="#用户线程的缺点：" class="headerlink" title="用户线程的缺点："></a>用户线程的<strong>缺点</strong>：</h5><ul>
<li>由于操作系统不参与线程的调度，如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了。</li>
<li>当一个线程开始运行后，除非它主动地交出 CPU 的使用权，否则它所在的进程当中的其他线程无法运行，因为用户态的线程没法打断当前运行中的线程，它没有这个特权，只有操作系统才有，但是用户线程不是由操作系统管理的。</li>
<li>由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会比较慢；</li>
</ul>
<h4 id="（二）内核线程（Kernel-Thread）"><a href="#（二）内核线程（Kernel-Thread）" class="headerlink" title="（二）内核线程（Kernel Thread）"></a>（二）内核线程（Kernel Thread）</h4><p>内核线程是由操作系统管理的，线程对应的 TCB 自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。</p>
<h5 id="内核线程的优点："><a href="#内核线程的优点：" class="headerlink" title="内核线程的优点："></a>内核线程的<strong>优点</strong>：</h5><ul>
<li>在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；</li>
<li>分配给线程，多线程的进程获得更多的 CPU 运行时间；</li>
</ul>
<h5 id="内核线程的缺点："><a href="#内核线程的缺点：" class="headerlink" title="内核线程的缺点："></a>内核线程的<strong>缺点</strong>：</h5><ul>
<li>在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB；</li>
<li>线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大；</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/13/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/13/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" class="post-title-link" itemprop="url">分布式事务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-13 12:03:59 / 修改时间：12:05:37" itemprop="dateCreated datePublished" datetime="2022-08-13T12:03:59+08:00">2022-08-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><pre><code>分布式事务就是指**事务的发起者、资源及资源管理器和事务协调者分别位于分布式系统的不同节点中**。银行跨行转账业务是一个典型分布式事务场景，假设A需要跨行转账给B，那么就涉及两个银行的数据，无法通过一个数据库的本地事务保证转账的ACID，只能够通过分布式事务来解决。
</code></pre>
<p>分布式事务<strong>部分遵循</strong> ACID 规范：</p>
<ul>
<li>原子性 &amp;&amp; 持久性：严格遵循</li>
<li>一致性：事务过程不一致，事务完成最终一致</li>
<li>隔离性：并行事务间不可影响；事务中间结果可见性允许安全放宽</li>
</ul>
<p>PS：分布式事务满足CAP的C，但是不满足ACID的C，也被称为最终一致、</p>
<h3 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h3><p>AT：非侵入式，容易开发，禁止使用XA事务的场景适用</p>
<p>XA：非侵入式，容易开发，但对资源长时间锁定，并发度低</p>
<p>SAGA：长事务适用，对中间结果不敏感的业务场景适用</p>
<p>TCC：适用于订单类业务，对中间状态有约束的业务</p>
<ul>
<li>RM 资源管理器，是业务服务，负责本地数据库的管理</li>
<li>TM 事务管理器，负责全局事务的状态管理，负责协调各个事务分支的执行</li>
<li>APP 应用程序，是业务服务，负责全局事务的发起</li>
</ul>
<h4 id="一、AT事务模式"><a href="#一、AT事务模式" class="headerlink" title="一、AT事务模式"></a>一、AT事务模式</h4><h5 id="（一）前提"><a href="#（一）前提" class="headerlink" title="（一）前提"></a>（一）前提</h5><ul>
<li>基于支持本地 ACID 事务的关系型数据库。</li>
<li>Java 应用，通过 JDBC 访问数据库</li>
</ul>
<h5 id="（二）工作机制"><a href="#（二）工作机制" class="headerlink" title="（二）工作机制"></a>（二）工作机制</h5><h5 id="一阶段："><a href="#一阶段：" class="headerlink" title="一阶段："></a><strong>一阶段：</strong></h5><ol>
<li>RM 侧，用户开启本地事务</li>
<li>RM 侧，用户每进行一次业务数据修改，假设是一个update语句，那么 AT 会做以下内容：<ol>
<li>根据update的条件，查询出修改前的数据，该数据称为BeforeImage</li>
<li>执行update语句，根据BeforeImage中的主键，查询出修改后的数据，该数据称为AfterImage</li>
<li>将BeforeImage和AfterImage保存到一张undolog表</li>
<li>将BeforeImage中的主键以及表名，该数据称为lockKey，记录下来，留待后续使用</li>
</ol>
</li>
<li>RM 侧，用户提交本地事务时，AT 会做以下内容：<ol>
<li>将2.4中记录的所有的lockKey，注册到 TC（即事务管理器seata）上</li>
<li>3.1中的注册处理会检查 TC 中，是否已存在冲突的主键+表名，如果有冲突，那么AT会睡眠等待后重试，没有冲突则保存</li>
<li>3.1成功完成后，提交本地事务</li>
</ol>
</li>
</ol>
<h5 id="二阶段-commit"><a href="#二阶段-commit" class="headerlink" title="二阶段 commit"></a><strong>二阶段 commit</strong></h5><ol>
<li>TC 会将当前这个全局事务所有相关的lockKey删除</li>
<li>TC 通知与当前这个全局事务相关的所有业务服务，告知全局事务已成功，可以删除undolog中保存的数据</li>
<li>RM 收到通知后，删除undolog中的数据</li>
</ol>
<h5 id="二阶段-rollback"><a href="#二阶段-rollback" class="headerlink" title="二阶段 rollback"></a>二阶段 rollback</h5><ol>
<li>TC 通知与当前这个全局事务相关的所有业务服务，告知全局事务失败，执行回滚</li>
<li>RM 收到通知后，对本地数据的修改进行回滚，回滚原理如下：<ol>
<li>从undolog中取出修改前后的BeforeImage和AfterImage</li>
<li>如果AfterImage与数据库中的当前记录校验一致，那么使用BeforeImage中的数据覆盖当前记录</li>
<li>如果AfterImage与数据库中的当前记录不一致，那么这个时候发生了<strong>脏回滚</strong>，此时需要人工介入解决</li>
</ol>
</li>
<li>TC 待全局事务所有的分支，都完成了回滚，TC 将此全局事务所有的lockKey删除</li>
</ol>
<h4 id="二、XA事务模式"><a href="#二、XA事务模式" class="headerlink" title="二、XA事务模式"></a>二、XA事务模式</h4><p>XA是由X&#x2F;Open组织提出的分布式事务的规范，XA规范主要定义了(全局)事务管理器(TM)和(局部)资源管理器(RM)之间的接口。本地的数据库如mysql在XA中扮演的是RM角色，XA的缺点就在于需要锁定资源</p>
<p>XA一共分为两阶段：</p>
<p>第一阶段（prepare）：即所有的参与者RM准备执行事务<strong>并锁住需要的资源</strong>。参与者ready时，向TM报告已准备就绪。 </p>
<p>第二阶段 (commit&#x2F;rollback)：当事务管理者(TM)确认所有参与者(RM)都ready后，向所有参与者发送commit命令。</p>
<p>XA 事务由一个或多个资源管理器（RM）、一个事务管理器（TM）和一个应用程序（ApplicationProgram）组成。</p>
<p><img src="https://segmentfault.com/img/bVcTlFw"></p>
<p>如果有任何一个参与者prepare失败，那么TM会通知所有完成prepare的参与者进行回滚。</p>
<h4 id="三、SAGA"><a href="#三、SAGA" class="headerlink" title="三、SAGA"></a>三、SAGA</h4><p>​	SAGA原理是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。</p>
<p><img src="https://segmentfault.com/img/bVcTlFy"></p>
<p>Saga一旦到了Cancel阶段，那么Cancel在业务逻辑上是不允许失败了。如果因为网络或者其他临时故障，导致没有返回成功，那么TM会不断重试，直到Cancel返回成功。</p>
<p>Saga事务的特点：</p>
<ul>
<li>并发度高，不用像XA事务那样长期锁定资源</li>
<li>需要定义正常操作以及补偿操作，开发量比XA大</li>
<li>一致性较弱，对于转账，可能发生A用户已扣款，最后转账又失败的情况</li>
</ul>
<h4 id="四、TCC"><a href="#四、TCC" class="headerlink" title="四、TCC"></a>四、TCC</h4><p>TCC分为3个阶段</p>
<ul>
<li>Try 阶段：尝试执行，完成所有业务检查（一致性）, 预留必须业务资源（准隔离性）</li>
<li>Confirm 阶段：如果所有分支的Try都成功了，则走到Confirm阶段。Confirm真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源</li>
<li>Cancel 阶段：如果所有分支的Try有一个失败了，则走到Cancel阶段。Cancel释放 Try 阶段预留的业务资源。</li>
</ul>
<p><img src="https://segmentfault.com/img/bVcTlFD"></p>
<p>TCC的Confirm&#x2F;Cancel阶段在业务逻辑上是不允许返回失败的，如果因为网络或者其他临时故障，导致不能返回成功，TM会不断的重试，直到Confirm&#x2F;Cancel返回成功。</p>
<p>TCC特点如下：</p>
<ul>
<li>并发度较高，无长期资源锁定。</li>
<li>开发量较大，需要提供Try&#x2F;Confirm&#x2F;Cancel接口。</li>
<li>一致性较好，不会发生SAGA已扣款最后又转账失败的情况</li>
</ul>
<h4 id="五、二阶段消息"><a href="#五、二阶段消息" class="headerlink" title="五、二阶段消息"></a>五、二阶段消息</h4><p>dtm首创了一种二阶段消息架构，该架构大大优于本地消息表和事务消息，可以完美替代本地消息表和事务消息。</p>
<p><img src="https://segmentfault.com/img/bVcXBhX"></p>
<p>一般情况下，时序图中的5个步骤会正常完成，整个业务按照预期进行，全局事务完成。</p>
<p>这里面有个新的内容需要解释一下，就是msg的提交是按照两个阶段发起的，第一阶段调用Prepare，第二阶段调用Commit，DTM收到Prepare调用后，不会调用分支事务，而是等待后续的Submit。只有收到了Submit，开始分支调用，最终完成全局事务。</p>
<p>对比本地消息表和事务消息，二阶段消息有以下优点：</p>
<ul>
<li>不需要队列，因此不需要消费者，用户就是简单的调用API</li>
<li>二阶段消息也有回查，但是回查是框架自动处理，且保证数据正确</li>
</ul>
<h4 id="六、最大努力通知"><a href="#六、最大努力通知" class="headerlink" title="六、最大努力通知"></a>六、最大努力通知</h4><p>发起通知方通过一定的机制最大努力将业务处理结果通知到接收方。具体包括：</p>
<p>有一定的消息重复通知机制。因为接收通知方可能没有接收到通知，此时要有一定的机制对消息重复通知。 消息校对机制。如果尽最大努力也没有通知到接收方，或者接收方消费消息后要再次消费，此时可由接收方主动向通知方查询消息信息来满足需求。 前面介绍的的本地消息表和事务消息都属于可靠消息，与这里介绍的最大努力通知有什么不同？</p>
<p>可靠消息一致性，发起通知方需要保证将消息发出去，并且将消息发到接收通知方，消息的可靠性关键由发起通知方来保证。</p>
<p>最大努力通知，发起通知方尽最大的努力将业务处理结果通知为接收通知方，但是可能消息接收不到，此时需要接收通知方主动调用发起通知方的接口查询业务处理结果，通知的可靠性关键在接收通知方。</p>
<p>解决方案上，最大努力通知需要：</p>
<ul>
<li>提供接口，让被通知方能够通过接口查询业务处理结果</li>
<li>消息队列ACK机制，消息队列按照间隔1min、5min、10min、30min、1h、2h、5h、10h的方式，逐步拉大通知间隔 ，直到达到通知要求的时间窗口上限。之后不再通知</li>
</ul>
<p>最大努力通知适用于业务通知类型，例如微信交易的结果，就是通过最大努力通知方式通知各个商户，既有回调通知，也有交易查询接口</p>
<p>最大努力通知更多是业务上的设计，在基础设施层，可以直接使用二阶段消息，或者事务消息、本地消息表</p>
<p>参考链接</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000040321750">分布式事务最经典的七种解决方案</a></p>
<p><a target="_blank" rel="noopener" href="https://dtm.pub/practice/theory.html">DTM</a></p>
<p><a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">SEATA</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/11/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/11/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">进程管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-11 22:12:56 / 修改时间：22:13:44" itemprop="dateCreated datePublished" datetime="2022-08-11T22:12:56+08:00">2022-08-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>​	代码在经过编译后生成二进制可执行文件，当运行这个可执行文件后，它会被装载到内存中，接着 CPU 会执行该程序中的每一条指令，这个程序就是<strong>进程</strong>。</p>
<h3 id="一、进程的状态"><a href="#一、进程的状态" class="headerlink" title="一、进程的状态"></a>一、进程的状态</h3><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/7-%E8%BF%9B%E7%A8%8B%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81.jpg"></h4><ul>
<li>运行状态（<em>Running</em>）：进程占用 CPU；</li>
<li>就绪状态（<em>Ready</em>）：可运行，由于其他进程占有CPU资源而等待；</li>
<li>阻塞状态（<em>Blocked</em>）：该进程正在等待某一事件发生（如等待输入&#x2F;输出操作的完成）而暂时停止运行，出让CPU资源；</li>
</ul>
<p>当然，进程还有另外两个基本状态：</p>
<ul>
<li>创建状态（<em>new</em>）：进程正在被创建时的状态；</li>
<li>结束状态（<em>Exit</em>）：进程正在从系统中消失时的状态；</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/8-%E8%BF%9B%E7%A8%8B%E4%BA%94%E4%B8%AA%E7%8A%B6%E6%80%81.jpg"></p>
<p>​	</p>
<p>​	如果有大量处于阻塞状态的进程，进程可能会占用着物理内存空间，导致资源浪费，所以在虚拟内存管理的操作系统中，<strong>通常会把阻塞状态的进程的物理内存空间换出到硬盘</strong>，等需要再次运行的时候，再从硬盘换入到物理内存。</p>
<p>​	因此就需要一个新的状态来<strong>描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态</strong>。这跟阻塞状态是不一样，阻塞状态是等待某个事件的返回。</p>
<p>另外，挂起状态可以分为两种：</p>
<ul>
<li>阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；</li>
<li>就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/10-%E8%BF%9B%E7%A8%8B%E4%B8%83%E4%B8%AD%E7%8A%B6%E6%80%81.jpg"></p>
<p>导致进程挂起的原因不只是因为进程所使用的内存空间不在物理内存，还包括如下情况：</p>
<ul>
<li>通过 sleep 让进程间歇性挂起，其工作原理是设置一个定时器，到期后唤醒进程。</li>
<li>用户希望挂起一个程序的执行，比如在 Linux 中用 <code>Ctrl+Z</code> 挂起进程</li>
</ul>
<h3 id="二、进程描述"><a href="#二、进程描述" class="headerlink" title="二、进程描述"></a>二、进程描述</h3><p>​	在操作系统中，是用<strong>进程控制块</strong>（<em>process control block，PCB</em>）数据结构来描述进程的，<strong>PCB 是进程存在的唯一标识</strong>，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。</p>
<h4 id="（一）PCB包含信息："><a href="#（一）PCB包含信息：" class="headerlink" title="（一）PCB包含信息："></a>（一）PCB包含信息：</h4><p><strong>进程描述信息：</strong></p>
<ul>
<li>进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；</li>
<li>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；</li>
</ul>
<p><strong>进程控制和管理信息：</strong></p>
<ul>
<li>进程当前状态，如 new、ready、running、waiting 或 blocked 等；</li>
<li>进程优先级：进程抢占 CPU 时的优先级；</li>
</ul>
<p><strong>资源分配清单：</strong></p>
<ul>
<li>有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I&#x2F;O 设备信息。</li>
</ul>
<p><strong>CPU 相关信息：</strong></p>
<ul>
<li>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。</li>
</ul>
<h3 id="三、进程控制"><a href="#三、进程控制" class="headerlink" title="三、进程控制"></a>三、进程控制</h3><h4 id="（一）创建进程"><a href="#（一）创建进程" class="headerlink" title="（一）创建进程"></a>（一）创建进程</h4><p>操作系统允许一个进程创建另一个进程，而且允许子进程继承父进程所拥有的资源。</p>
<p>创建进程的过程如下：</p>
<ul>
<li>申请一个空白的 PCB，并向 PCB 中填写一些控制和管理进程的信息，比如进程的唯一标识等；</li>
<li>为该进程分配运行时所必需的资源，比如内存资源；</li>
<li>将 PCB 插入到就绪队列，等待被调度运行；</li>
</ul>
<h4 id="（二）终止进程"><a href="#（二）终止进程" class="headerlink" title="（二）终止进程"></a><strong>（二）终止进程</strong></h4><p>进程可以有 3 种终止方式：正常结束、异常结束以及外界干预（kill -9 pid）。</p>
<p>当子进程被终止时，其在父进程处继承的资源应当还给父进程。而当父进程被终止时，该父进程的子进程就变为孤儿进程，会被 1 号进程收养，并由 1 号进程对它们完成状态收集工作。</p>
<p>终止进程的过程如下：</p>
<ul>
<li>查找需要终止的进程的 PCB；</li>
<li>如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程；</li>
<li>如果其还有子进程，则应将该进程的子进程交给 1 号进程接管；</li>
<li>将该进程所拥有的全部资源都归还给操作系统；</li>
<li>将其从 PCB 所在队列中删除；</li>
</ul>
<h4 id="（三）阻塞进程"><a href="#（三）阻塞进程" class="headerlink" title="（三）阻塞进程"></a><strong>（三）阻塞进程</strong></h4><p>当进程需要等待某一事件完成时，它可以调用阻塞语句把自己阻塞等待。而一旦被阻塞等待，它只能由另一个进程唤醒。</p>
<p>阻塞进程的过程如下：</p>
<ul>
<li>找到将要被阻塞进程标识号对应的 PCB；</li>
<li>如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行；</li>
<li>将该 PCB 插入到阻塞队列中去；</li>
</ul>
<h4 id="（四）唤醒进程"><a href="#（四）唤醒进程" class="headerlink" title="（四）唤醒进程"></a><strong>（四）唤醒进程</strong></h4><p>进程由「运行」转变为「阻塞」状态是由于进程必须等待某一事件的完成，所以处于阻塞状态的进程是绝对不可能叫醒自己的。</p>
<p>如果某进程正在等待 I&#x2F;O 事件，需由别的进程发消息给它，则只有当该进程所期待的事件出现时，才由发现者进程用唤醒语句叫醒它。</p>
<p>唤醒进程的过程如下：</p>
<ul>
<li>在该事件的阻塞队列中找到相应进程的 PCB；</li>
<li>将其从阻塞队列中移出，并置其状态为就绪状态；</li>
<li>把该 PCB 插入到就绪队列中，等待调度程序调度；</li>
</ul>
<p>进程的阻塞和唤醒是一对功能相反的语句，如果某个进程调用了阻塞语句，则必有一个与之对应的唤醒语句。</p>
<h3 id="四、进程上下文切换"><a href="#四、进程上下文切换" class="headerlink" title="四、进程上下文切换"></a>四、进程上下文切换</h3><p>​	进程是由内核管理和调度的，故进程的切换只发生在内核态，因此<strong>进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源，以及硬件上下文资源。</strong></p>
<h4 id="（一）进程切换过程"><a href="#（一）进程切换过程" class="headerlink" title="（一）进程切换过程"></a>（一）进程切换过程</h4><ol>
<li><p>保存处理机上下文，包括程序计数器和其他寄存器。</p>
</li>
<li><p>更新PCB信息。</p>
</li>
<li><p>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</p>
</li>
<li><p>选择另一个进程执行，并更新其PCB。</p>
</li>
<li><p>更新内存管理的数据结构。</p>
</li>
<li><p>恢复处理机上下文</p>
</li>
</ol>
<h4 id="（二）进程上下文切换场景"><a href="#（二）进程上下文切换场景" class="headerlink" title="（二）进程上下文切换场景"></a>（二）进程上下文切换场景</h4><ul>
<li>为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行；</li>
<li>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行；</li>
<li>当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度；</li>
<li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行；</li>
<li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；</li>
</ul>
<h3 id="五、进程调度方法"><a href="#五、进程调度方法" class="headerlink" title="五、进程调度方法"></a>五、进程调度方法</h3><ul>
<li><p><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</p>
</li>
<li><p><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</p>
</li>
<li><p><strong>时间片轮转调度算法</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</p>
</li>
<li><p><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</p>
</li>
<li><p><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/09/OutOfMemoryError/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/09/OutOfMemoryError/" class="post-title-link" itemprop="url">OutOfMemoryError</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-09 11:28:39 / 修改时间：11:29:27" itemprop="dateCreated datePublished" datetime="2022-08-09T11:28:39+08:00">2022-08-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Jvm/" itemprop="url" rel="index"><span itemprop="name">Jvm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="一、java堆溢出"><a href="#一、java堆溢出" class="headerlink" title="一、java堆溢出"></a>一、java堆溢出</h4><p>​	java堆用于存储对象实例，如果不断创建对象，同时保证GC Roots与对象之间可达，那么随着对象数目的增加，总容量达到最大堆限制时，就会发生内存溢出异常。</p>
<p>​	java堆内存的OutOfMemoryError异常是实际应用中最常见的内存溢出异常。出现java堆溢出异常时，异常堆栈信息 <code>java.lang.OutOfMemoryError</code> 会进一步跟随提示 <code>Java heap space</code></p>
<h5 id="（一）如何解决堆溢出异常"><a href="#（一）如何解决堆溢出异常" class="headerlink" title="（一）如何解决堆溢出异常"></a>（一）如何解决堆溢出异常</h5><ol>
<li>通过内存映像分析工具对Dump出来的堆转储快照进行分析</li>
<li>确定内存中导致OOM的对象是否有必要存在，也就是分清楚是内存泄露还是内存溢出</li>
<li>若是内存泄露，那么就需要通过工具查看泄露对象与GC Roots的引用链，分析什么原因导致垃圾回收器无法回收这些对象</li>
<li>若是内存溢出问题，那么就说明内存中的对象确实必须存活，因此就需要去调整Java虚拟机的堆参赛，或者在代码上检查是否存在某些对象的生命周期过长、持有状态时间过长、存储结构设计不合理等问题</li>
</ol>
<h4 id="二、虚拟机栈和本地方法栈溢出"><a href="#二、虚拟机栈和本地方法栈溢出" class="headerlink" title="二、虚拟机栈和本地方法栈溢出"></a>二、虚拟机栈和本地方法栈溢出</h4><ul>
<li>StackOverflowError：线程请求栈的深度大于虚拟机所运行的最大深度</li>
<li>OutOfMemoryError：若虚拟机栈的内存运行动态拓展，且拓展栈容量无法申请到足够内存</li>
</ul>
<p>​	在HotSpot虚拟机中，由于无法动态拓展栈容量，因此无论是由于栈帧太大还是虚拟机栈容量太小，当新的栈帧内存无法分配的时候，都是抛出StackOverflowError异常。</p>
<h4 id="三、方法区和运行时常量池溢出"><a href="#三、方法区和运行时常量池溢出" class="headerlink" title="三、方法区和运行时常量池溢出"></a>三、方法区和运行时常量池溢出</h4><p>​	运行时常量池属于方法区&#x2F;永久代的一部 分，因此当运行时常量池溢出，在OutOfMemoryError后面跟随的提示信息是PermGen space。</p>
<p>​	方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量 Class 的应用中，需要特别注意类的回收状况。</p>
<p>​	除了使用 CGLib 字节码增强和动态语言之外，常见的情况还有：大量 JSP 或动态产生 JSP 文件的应用（JSP 第一次运行时需要编译为 Java 类）、基于 OSGi 的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。</p>
<p>参考链接</p>
<p><a target="_blank" rel="noopener" href="https://book.douban.com/subject/6522893/">深入理解Java虚拟机</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/08/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/08/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">JVM内存模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-08 16:31:07 / 修改时间：16:33:49" itemprop="dateCreated datePublished" datetime="2022-08-08T16:31:07+08:00">2022-08-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><h4 id="一、程序计数器（Program-Counter-Register）"><a href="#一、程序计数器（Program-Counter-Register）" class="headerlink" title="一、程序计数器（Program Counter Register）"></a>一、程序计数器（Program Counter Register）</h4><p>​	程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</p>
<p>​	在虚拟机概念模型里（概念模型，各种虚拟机可能会通过一些更高效的方式实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令：分支、跳转、循环、异常处理、线程恢复等基础操作都会依赖这个计数器来完成。</p>
<p>​	<strong>每个线程都有独立的程序计数器</strong>，用来在线程切换后能恢复到正确的执行位置，各条线程之间的计数器互不影响，独立存储。所以它是一个“线程私有”的内存区域。此内存区域是唯一一个在JVM规范中没有规定任何OutOfMemoryError情况的区域。</p>
<h4 id="二、虚拟机栈（VM-Stack）"><a href="#二、虚拟机栈（VM-Stack）" class="headerlink" title="二、虚拟机栈（VM Stack）"></a>二、虚拟机栈（VM Stack）</h4><p>​	虚拟机栈是线程私有的内存区域，它的生命周期与线程相同。虚拟机栈描述的是java方法执行的内存模型，每个方法执行的同时，虚拟机栈都会创建一个栈帧（Stack Frame）用于存储<strong>局部变量表、操作数栈、动态链接、方法出口</strong>等信息。</p>
<p>​	每个方法从调用直至完成的过程，都对应着一个栈帧从入栈到出栈的过程。每当一个方法执行完成时，该栈帧就会弹出栈帧的元素作为这个方法的返回值，并且清除这个栈帧，Java栈的栈顶的栈帧就是当前正在执行的活动栈，也就是当前正在执行的方法。就像是组成动画的一帧一帧的图片，方法的调用过程也是由栈帧切换来产生结果。</p>
<p>​	<strong>局部变量表</strong>存放了编译器可知的各种<strong>基本数据类型</strong>（int、short、byte、char、double、float、long、boolean）、<strong>对象引用</strong>（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和<strong>return Address类型</strong>（指向了一跳字节码指令的地址）。</p>
<p>​	在JVM规范中，对这个区域规定了两种异常情况：如果线程请求的栈深度大于虚拟机允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，在扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>
<h4 id="三、本地方法栈（-Native-Method-Stack）"><a href="#三、本地方法栈（-Native-Method-Stack）" class="headerlink" title="三、本地方法栈（ Native Method Stack）"></a>三、本地方法栈（ Native Method Stack）</h4><p>​	本地方法栈和虚拟机栈所发挥的作用是很相似的，<strong>它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务</strong>。Sun HotSpot 直接就把本地方法栈和虚拟机栈合二为一。本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<h4 id="四、堆（Heap）"><a href="#四、堆（Heap）" class="headerlink" title="四、堆（Heap）"></a>四、堆（Heap）</h4><p>​	java堆是虚拟机所管理内存的最大一块，在虚拟机启动时创建，<strong>所有的对象实例以及数组</strong>都应当在堆上分配。</p>
<p>​	堆由垃圾收集器自动回收，堆区由各子线程共享使用；通常情况下，它占用的空间是所有内存区域中最大的，但如果无节制地创建大量对象，也容易消耗完所有的空间；堆的内存空间既可以固定大小，也可运行时动态地调整，通过参数-Xms设定初始值、-Xmx设定最大值。</p>
<h4 id="五、方法区（Method-Area）"><a href="#五、方法区（Method-Area）" class="headerlink" title="五、方法区（Method Area）"></a>五、方法区（Method Area）</h4><p>​	方法区是被所有线程共享的内存区域，用来存储已被虚拟机加载的<strong>类信息、常量、静态变量</strong>、JIT（just in time,即时编译技术）编译后的代码缓存等数据。<br>​	<strong>运行时常量池</strong>是方法区的一部分，Class文件除了类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期间生成的<strong>各种字面量和符合引用</strong>，这部分将在类加载后存放到运行时常量池中。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/07/Volatile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/07/Volatile/" class="post-title-link" itemprop="url">Volatile</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-07 14:29:27 / 修改时间：14:31:05" itemprop="dateCreated datePublished" datetime="2022-08-07T14:29:27+08:00">2022-08-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Java并发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><h4 id="一、什么是volatile"><a href="#一、什么是volatile" class="headerlink" title="一、什么是volatile"></a>一、什么是volatile</h4><p>​	<code>volatile</code>关键字是Java虚拟机提供的最轻量级的同步机制</p>
<h3 id="二、volatile的作用及原理"><a href="#二、volatile的作用及原理" class="headerlink" title="二、volatile的作用及原理"></a>二、volatile的作用及原理</h3><h5 id="（一）可见性"><a href="#（一）可见性" class="headerlink" title="（一）可见性"></a>（一）可见性</h5><p>​	内存不可见的主要原因就是<strong>Java内存模型中的本地内存和主内存之间的值不一致</strong>所导致，因此解决可见性问题是就需要实现多个线程共同访问共享变量时，某个线程修改了此变量，其他线程能立即看到修改后的值。</p>
<p>​	通过<code>volatile</code>修饰的变量，生成汇编指令时会比普通的变量多出一个<code>Lock</code>指令，这个<code>Lock</code>指令就是<code>volatile</code>关键字可以保证内存可见性的关键，其作用如下：</p>
<ul>
<li>在工作内存数据修改后立即将数据刷新到主内存。</li>
<li>刷新到主内存时会使得其他工作内存的数据无效。</li>
</ul>
<h5 id="（二）有序性"><a href="#（二）有序性" class="headerlink" title="（二）有序性"></a>（二）有序性</h5><p>​	保证程序执行的顺序按照代码的先后顺序执行。因为JMM模型中允许编译器和处理器为了效率，进行<strong>指令重排序的优化</strong>。指令重排序在单线程内表现为串行语义，不会影响结果，但在多线程中会表现为无序。因此在多线程并发编程中，需要考虑如何在多线程环境下即允许部分指令重排的同时，又要保证有序性</p>
<p>​	<code>volatile</code>是通过编译器在生成字节码时，在指令序列中添加“<strong>内存屏障</strong>”来禁止指令重排序的</p>
<p>​	JVM的实现<strong>会在volatile读写前后均加上内存屏障</strong>，在一定程度上保证有序性。如下所示：</p>
<blockquote>
<p>LoadLoadBarrier<br>volatile 读操作<br>LoadStoreBarrier</p>
<p>StoreStoreBarrier<br>volatile 写操作<br>StoreLoadBarrier</p>
</blockquote>
<p>JMM层面的“<strong>内存屏障</strong>”：</p>
<table>
<thead>
<tr>
<th><strong>屏障类型</strong></th>
<th><strong>指令示例</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad Barriers</td>
<td>Load1;LoadLoad;Load2</td>
<td>保证Load1数据的读取先于Load2及后续所有读取指令的执行</td>
</tr>
<tr>
<td>StoreStore Barriers</td>
<td>Store1;StoreStore;Store2</td>
<td>保证Store1数据刷新到主内存先于Store2及后续所有存储指令</td>
</tr>
<tr>
<td>LoadStore Barriers</td>
<td>Load1;LoadStore;Store2</td>
<td>保证Load1数据的读取先于Store2及后续的所有存储指令刷新到主内存</td>
</tr>
<tr>
<td>StoreLoad Barriers</td>
<td>Store1;StoreLoad;Load2</td>
<td>保证Store1数据刷新到主内存先于Load2及后续所有读取指令的执行</td>
</tr>
</tbody></table>
<p>参考链接：<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/133851347">https://zhuanlan.zhihu.com/p/133851347</a><br>tps:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;6972424311667687460</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/06/%E5%88%86%E5%B8%83%E5%BC%8FID/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/06/%E5%88%86%E5%B8%83%E5%BC%8FID/" class="post-title-link" itemprop="url">分布式ID</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-06 21:45:21 / 修改时间：21:46:27" itemprop="dateCreated datePublished" datetime="2022-08-06T21:45:21+08:00">2022-08-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h2><h4 id="一、什么是分布式ID"><a href="#一、什么是分布式ID" class="headerlink" title="一、什么是分布式ID"></a>一、什么是分布式ID</h4><p>在分布式系统中，经常需要一些全局唯一的ID对数据、消息、http请求等进行唯一标识。那么这个全局唯一ID就叫分布式ID</p>
<h4 id="二、为什么要分布式ID"><a href="#二、为什么要分布式ID" class="headerlink" title="二、为什么要分布式ID"></a>二、为什么要分布式ID</h4><p>以MySQL数据库为，在我们业务数据量不大的时候，单库单表完全可以支撑现有业务，数据再大一点搞个MySQL主从同步读写分离也能对付。但随着数据日渐增长，主从同步也扛不住了，就需要对数据库进行分库分表，但分库分表后需要有一个唯一ID来标识一条数据，数据库的自增ID显然不能满足需求；特别一点的如订单、优惠券也都需要有<code>唯一ID</code>做标识。此时一个能够生成<code>全局唯一ID</code>的系统是非常必要的。那么这个<code>全局唯一ID</code>就叫<code>分布式ID</code>。</p>
<h4 id="三、分布式ID需要满足的条件"><a href="#三、分布式ID需要满足的条件" class="headerlink" title="三、分布式ID需要满足的条件"></a>三、分布式ID需要满足的条件</h4><ul>
<li>全局唯一：必须保证ID是全局性唯一的，基本要求</li>
<li>高性能：高可用低延时，ID生成响应要块，否则反倒会成为业务瓶颈</li>
<li>高可用：100%的可用性是骗人的，但是也要无限接近于100%的可用性</li>
<li>好接入：要秉着拿来即用的设计原则，在系统设计和实现上要尽可能的简单</li>
<li>趋势递增：最好趋势递增，这个要求就得看具体业务场景了，一般不严格要求</li>
</ul>
<h4 id="四、分布式ID生成器方式以及优缺点"><a href="#四、分布式ID生成器方式以及优缺点" class="headerlink" title="四、分布式ID生成器方式以及优缺点"></a>四、分布式ID生成器方式以及优缺点</h4><h5 id="（一）UUID"><a href="#（一）UUID" class="headerlink" title="（一）UUID"></a>（一）UUID</h5><p>优点：</p>
<ul>
<li>生成足够简单，本地生成无网络消耗，具有唯一性</li>
</ul>
<p>缺点：</p>
<ul>
<li>无序的字符串，不具备趋势自增特性</li>
<li>没有具体的业务含义</li>
<li>长度过长16字节128位，36位长度的字符串，存储以及查询对MySQL的性能消耗较大</li>
</ul>
<h5 id="（二）数据库自增ID"><a href="#（二）数据库自增ID" class="headerlink" title="（二）数据库自增ID"></a>（二）数据库自增ID</h5><p>​	基于数据库的<code>auto_increment</code>自增ID完全可以充当<code>分布式ID</code>，具体实现：需要一个单独的MySQL实例用来生成ID，当我们需要一个ID的时候，向表中插入一条记录返回<code>主键ID</code></p>
<p>优点：</p>
<ul>
<li>实现简单，ID单调自增，数值类型查询速度快</li>
</ul>
<p>缺点：</p>
<ul>
<li>DB单点存在宕机风险，无法扛住高并发场景</li>
</ul>
<h5 id="（三）Redis"><a href="#（三）Redis" class="headerlink" title="（三）Redis"></a>（三）Redis</h5><p>​	利用redis的incr命令实现ID的原子性自增。</p>
<h5 id="（四）雪花算法（SnowFlake）"><a href="#（四）雪花算法（SnowFlake）" class="headerlink" title="（四）雪花算法（SnowFlake）"></a>（四）雪花算法（SnowFlake）</h5><p>​	Snowflake生成的是Long类型的ID，一个Long类型占8个字节，每个字节占8比特，也就是说一个Long类型占64个比特。Snowflake ID组成结构：正数位(占1比特)+ 时间戳(占41比特)+ 机器ID(占5比特)+ 数据中心(占5比特)+ 自增值(占12比特)，总共64比特组成的一个Long类型。</p>
<ul>
<li>第一个bit位(1bit)：Java中long的最高位是符号位代表正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0。</li>
<li>时间戳部分(41bit)：毫秒级的时间，不建议存当前时间戳，而是用(当前时间戳 - 固定开始时间戳)的差值，可以使产生的ID从更小的值开始;41位的时间戳可以使用69年，(1L &lt;&lt; 41) &#x2F; (1000L * 60 * 60 * 24 * 365) &#x3D; 69年</li>
<li>工作机器id(10bit)：也被叫做workId，这个可以灵活配置，机房或者机器号组合都可以。</li>
<li>序列号部分(12bit)，自增值支持同一毫秒内同一个节点可以生成4096个ID</li>
</ul>
<p>​	snowflake在1024台机器上同时分布的产生ID可以保证唯一&#96;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/05/Dockerfile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/05/Dockerfile/" class="post-title-link" itemprop="url">Dockerfile</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-05 18:15:19 / 修改时间：18:16:03" itemprop="dateCreated datePublished" datetime="2022-08-05T18:15:19+08:00">2022-08-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><h3 id="一、dockerfile编写"><a href="#一、dockerfile编写" class="headerlink" title="一、dockerfile编写"></a>一、dockerfile编写</h3><p>Dockerfile编写注意点</p>
<ul>
<li>Dockerfile文件不宜过长，层级越多最终制作出来的镜像也就越大。</li>
<li>构建出来的镜像不要包含不需要的内容，如日志、安装临时文件等。</li>
<li>尽量使用运行时的基础镜像，不需要将构建时的过程也放到运行时的Dockerfile里。</li>
</ul>
<p>Dockerfile的常用语法</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>基于哪个镜像实现该容器</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>镜像维护者姓名或邮箱地址</td>
</tr>
<tr>
<td>ENV</td>
<td>声明环境变量</td>
</tr>
<tr>
<td>RUN</td>
<td>用于执行后面跟着的命令行命令，但是在docker build时运行</td>
</tr>
<tr>
<td>ADD</td>
<td>拷贝文件或目录到容器中，如果是URL或压缩包便会自动下载或自动解压</td>
</tr>
<tr>
<td>COPY</td>
<td>拷贝文件或目录到容器中，跟ADD类似，但不具备自动下载或解压的功能</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>容器内应用可使用的端口</td>
</tr>
<tr>
<td>CMD</td>
<td>类似于 RUN 指令，用于运行程序，但是在 docker run时运行</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。但是如果运行docker run 时使用了 –entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序</td>
</tr>
<tr>
<td>VOLUME</td>
<td>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。可以避免容器不断变大，且避免容器重要的数据因容器重启丢失</td>
</tr>
</tbody></table>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于哪个镜像</span></span><br><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span></span><br><span class="line"><span class="comment"># 将本地文件夹挂载到当前容器</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /tmp</span></span><br><span class="line"><span class="comment"># 拷贝文件到容器，chongma-eureka-1.0.1-SNAPSHOT.jar这里是maven打包后的名字</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> XXXXXX.jar XXX.jar</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> bash -c <span class="string">&#x27;touch /XXX.jar&#x27;</span></span></span><br><span class="line"><span class="comment"># 配置容器启动后执行的命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash">  [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-Djava.security.egd=file:/dev/./urandom&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/XXX.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h3 id="二、docker命令"><a href="#二、docker命令" class="headerlink" title="二、docker命令"></a>二、docker命令</h3><p>1.docker image rm<br>2.docker stats 内存占用<br>3.docker image inspect docker.io&#x2F;mysql:latest|grep -i version<br>4.docker cp &#x2F;www&#x2F;runoob 96f7f14e99ab:&#x2F;www&#x2F;<br>5.查看docker容器：docker images<br>6.查看docker运行容器：docker ps<br>7.进入容器内部：docker exec -it nginx &#x2F;bin&#x2F;bash<br>8.退出容器:exit<br>9.docker复制文件：docker cp &#x2F;www&#x2F;runoob 96f7f14e99ab:&#x2F;www&#x2F;<br>10.docker停止容器：docker stop<br>11.docker删除容器：docker rm<br>12.docker日志：docker logs –since&#x3D;”2016-07-01” –tail&#x3D;10 mynginx<br>13.vi &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service 远程</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/04/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/04/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">项目部署</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-04 21:45:36 / 修改时间：21:46:46" itemprop="dateCreated datePublished" datetime="2022-08-04T21:45:36+08:00">2022-08-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/" itemprop="url" rel="index"><span itemprop="name">项目实践</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><h3 id="一、Git上传前端代码"><a href="#一、Git上传前端代码" class="headerlink" title="一、Git上传前端代码"></a>一、Git上传前端代码</h3><ol>
<li><p>git生成一个公钥（ssh-keygen） 配置到git仓库中</p>
</li>
<li><p>在Github上创建一个空的项目目录</p>
</li>
<li><p>将这个项目目录clone到本地</p>
</li>
<li><p>连接到远程仓库git init 初始化git</p>
</li>
<li><p>git add .添加到暂存区</p>
</li>
<li><p>git commit <strong><code>-m &quot;first commit&quot;</code></strong></p>
</li>
</ol>
<p>git remote rm origin</p>
<p>git remote show origin</p>
<p>git config –global core.longpaths true：文件名过长</p>
<ol start="7">
<li>git remote add origin <a href="mailto:&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#x65;&#x65;&#x2e;&#99;&#x6f;&#109;">&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#x65;&#x65;&#x2e;&#99;&#x6f;&#109;</a>:whning&#x2F;travel-vue.git与远程仓库关联 后面为地址</li>
</ol>
<p>git remote add origin <a href="mailto:&#x67;&#105;&#116;&#x40;&#x67;&#105;&#116;&#101;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">&#x67;&#105;&#116;&#x40;&#x67;&#105;&#116;&#101;&#x65;&#x2e;&#x63;&#x6f;&#x6d;</a>:whning&#x2F;food-cloud.git</p>
<p>方法二：使用ssh获得远程库 然后复制到文件内</p>
<p>ssh -T <a href="mailto:&#103;&#105;&#116;&#x40;&#103;&#105;&#116;&#101;&#101;&#x2e;&#x63;&#x6f;&#x6d;">&#103;&#105;&#116;&#x40;&#103;&#105;&#116;&#101;&#101;&#x2e;&#x63;&#x6f;&#x6d;</a>：验证是否成功</p>
<ol start="8">
<li>git push -u origin master 上传到远程仓库 如果出现错误且是第一次提交 那么就 -f</li>
</ol>
<h3 id="二、Nginx部署前端代码"><a href="#二、Nginx部署前端代码" class="headerlink" title="二、Nginx部署前端代码"></a>二、Nginx部署前端代码</h3><ol>
<li><p>Linux下载git node npm</p>
</li>
<li><p>clone 项目并npm run build 打包</p>
</li>
<li><p>Nginx解决跨域问题</p>
</li>
</ol>
<h3 id="三、docker部署Nginx"><a href="#三、docker部署Nginx" class="headerlink" title="三、docker部署Nginx"></a>三、docker部署Nginx</h3><ol>
<li><p>docker search Nginx </p>
</li>
<li><p>docker pull Nginx docker build -t blogserver:2.0 .</p>
</li>
<li><p>复制Nginx容器中的配置文件到主机内 docker cp（docker cp  96f7f14e99ab:&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf &#x2F;home&#x2F;nginx01&#x2F;default.conf）</p>
</li>
<li><p>通过挂载实现主机内文件与容器内文件配置 docker run -d -p 80:333 -v &#x2F;home&#x2F;nginx01&#x2F;default.conf:&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf -v &#x2F;home&#x2F;nginx01&#x2F;www&#x2F;dist:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html –name nginx01 nginx</p>
</li>
</ol>
<p>docker run -d -p 80:333 –name nginx01 nginx</p>
<h3 id="四、docker部署MySQL"><a href="#四、docker部署MySQL" class="headerlink" title="四、docker部署MySQL"></a>四、docker部署MySQL</h3><ol>
<li><p>docker search</p>
</li>
<li><p>docker pull mysql</p>
</li>
<li><p>docker run -itd –name mysql2 -p 3306:3306  -e MYSQL_ROOT_PASSWORD&#x3D;123456 mysql</p>
</li>
<li><p>本地连接 docker exec -it mysql2 &#x2F;bin&#x2F;bash 进入容器内部 mysql -uroot -p123456 进入MySQL</p>
</li>
<li><p>远程连接</p>
</li>
</ol>
<h3 id="五、docker部署redis"><a href="#五、docker部署redis" class="headerlink" title="五、docker部署redis"></a>五、docker部署redis</h3><ol>
<li><p>docker run -it -d -p 6379:6379 –name redis2 redis</p>
</li>
<li><p>docker exec -it redis2 &#x2F;bin&#x2F;bash</p>
</li>
<li><p>redis-cli</p>
</li>
<li><p>远程连接</p>
</li>
</ol>
<h3 id="六、docker部署MongoDB"><a href="#六、docker部署MongoDB" class="headerlink" title="六、docker部署MongoDB"></a>六、docker部署MongoDB</h3><ol>
<li><p>docker run –name mongodb2 –network travel –network-alias mongodb2  -p 27017:27017 -d mongo 容器运行</p>
</li>
<li><p>docker exec -it mongodb2 mongo admin 进入容器</p>
</li>
<li><p>db.createUser({ user: ‘root’, pwd: ‘123456’, roles: [ { role: “userAdminAnyDatabase”, db: “admin” } ] }); 添加用户</p>
</li>
<li><p>mongodb建议本地访问 无法远程连接</p>
</li>
</ol>
<h3 id="七、docker部署Es"><a href="#七、docker部署Es" class="headerlink" title="七、docker部署Es"></a>七、docker部署Es</h3><p>docker run -e ES_JAVA_OPTS&#x3D;”-Xms512m -Xmx512m” -e “discovery.type&#x3D;single-node” -d -p 9200:9200 -p 9300:9300  -v &#x2F;usr&#x2F;share&#x2F;elasticsearch.yml:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml –name elasticsearch elasticsearch:7.9.3</p>
<p>-Xms：初始分配内存 -Xmx：最大分配内存</p>
<p>-e 对配置文件进行修改 限制es内存占用</p>
<p>docker cp elasticsearch:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml &#x2F;usr&#x2F;share&#x2F;elasticsearch.yml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker cp /home/software/ik elasticsearch:/elasticsearch/plugins</span><br><span class="line"></span><br><span class="line">&#123;&quot;settings&quot;:&#123;&quot;index&quot;:&#123;&quot;number_of_shards&quot;:&quot;5&quot;,&quot;analysis&quot;:&#123;&quot;analyzer&quot;:&#123;&quot;default&quot;:&#123;&quot;type&quot;:&quot;ik_max_word&quot;&#125;&#125;&#125;&#125;&#125;,&quot;mappings&quot;:&#123;&quot;article&quot;:&#123;&quot;_all&quot;:&#123;&quot;enabled&quot;:false&#125;,&quot;properties&quot;:&#123;&quot;createtime&quot;:&#123;&quot;type&quot;:&quot;text&quot;&#125;,&quot;city&quot;:&#123;&quot;type&quot;:&quot;text&quot;&#125;,&quot;like&quot;:&#123;&quot;type&quot;:&quot;text&quot;&#125;,&quot;name&quot;:&#123;&quot;type&quot;:&quot;text&quot;&#125;,&quot;id&quot;:&#123;&quot;type&quot;:&quot;text&quot;&#125;,&quot;title&quot;:&#123;&quot;type&quot;:&quot;text&quot;&#125;,&quot;userId&quot;:&#123;&quot;type&quot;:&quot;text&quot;&#125;,&quot;content&quot;:&#123;&quot;type&quot;:&quot;text&quot;&#125;&#125;&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.9.3/elasticsearch-analysis-ik-7.9.3.zip</span><br></pre></td></tr></table></figure>

<h3 id="八、docker部署springboot"><a href="#八、docker部署springboot" class="headerlink" title="八、docker部署springboot"></a>八、docker部署springboot</h3><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><p>打包成为jar 添加dockerfile为制作docker镜像并使用容器运行</p>
<p>docker build -t travel:v1 .</p>
<p>docker run -itd –name travel2 -p 8083:8083 travel:v1</p>
<h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it travel2 /bin/bash</span><br><span class="line"></span><br><span class="line">docker run -d --name travel2 -p <span class="number">8083</span>:<span class="number">8083</span> -v /home/springboot/travel/travel.<span class="property">jar</span>:<span class="regexp">/usr/</span>app.<span class="property">jar</span> --link <span class="attr">elasticsearch</span>:elasticsearch --link <span class="attr">redis2</span>:redis2 --network travel --network-alias travel2 40eccaa4f420 java -jar -<span class="title class_">Xms256</span>m -<span class="title class_">Xmx256</span>m /usr/app.<span class="property">jar</span></span><br><span class="line"></span><br><span class="line">-p <span class="number">8781</span>:<span class="number">8081</span> 端口映射，<span class="number">8081</span>是jar里面内置tomcat的端口。</span><br><span class="line">-v /app/pms/card-api-pms-<span class="number">0.0</span><span class="number">.1</span>.<span class="property">jar</span>:<span class="regexp">/usr/</span>app.<span class="property">jar</span> 将容器中/usr/app.<span class="property">jar</span>文件挂载到主机/app/pms/card-api-pms-<span class="number">0.0</span><span class="number">.1</span>.<span class="property">jar</span>文件，这个是关键。</span><br><span class="line"><span class="attr">java</span>:<span class="number">8</span> 使用java <span class="number">8</span>的版本镜像</span><br><span class="line">java -jar -<span class="title class_">Xms256</span>m -<span class="title class_">Xmx256</span>m /usr/app.<span class="property">jar</span> 运行/usr/app.<span class="property">jar</span>的jar包，前面已经将此jar包跟主机文件挂载，所以实际运行的就是主机目录下的card-api-pms-<span class="number">0.0</span><span class="number">.1</span>.<span class="property">jar</span>；另外在运行jar包的时候指定了分配给jvm的内存大小，你不指定就会使用默认机制占用内存。</span><br></pre></td></tr></table></figure>

<h5 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h5><p>使用<strong>dockerfile-maven-plugin</strong>插件</p>
<ol>
<li>编写Dockerfile文件，并放在项目的根目录下，和 pom.xml 在一起。</li>
<li>在pom.xml 添加一些配置</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 镜像名称 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">imageName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Dockerfile文件所在目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dockerDirectory</span>&gt;</span>src/main/docker<span class="tag">&lt;/<span class="name">dockerDirectory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- docker所在宿主机ip 2375为docker开启的远程访问端口 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dockerHost</span>&gt;</span>http://XXXX:2375<span class="tag">&lt;/<span class="name">dockerHost</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>开启docker远程连接（有风险）</li>
<li>编写并运行maven命令（clean package docker:build -DskipTests）</li>
<li>上传镜像到远程服务器</li>
</ol>
<h3 id="九、问题"><a href="#九、问题" class="headerlink" title="九、问题"></a>九、问题</h3><h4 id="问题一：前端项目打包-首页-404"><a href="#问题一：前端项目打包-首页-404" class="headerlink" title="问题一：前端项目打包 首页 404"></a>问题一：前端项目打包 首页 404</h4><p>原因：router为history模式 无法在本地显示；build打包中的转为publicStack：’.&#x2F;‘</p>
<p>解决方法：转为hash模式 但不必要 因为在web端会正常显示</p>
<h4 id="问题二：elementUI-图标不显示"><a href="#问题二：elementUI-图标不显示" class="headerlink" title="问题二：elementUI 图标不显示"></a>问题二：elementUI 图标不显示</h4><p>原因：打包后目录变化 原目录不可用</p>
<p>解决方法：在until.js中的一段添加 publicPath: ‘..&#x2F;..&#x2F;‘</p>
<h4 id="问题三：前端无法与后端通过Ajax进行交互"><a href="#问题三：前端无法与后端通过Ajax进行交互" class="headerlink" title="问题三：前端无法与后端通过Ajax进行交互"></a>问题三：前端无法与后端通过Ajax进行交互</h4><p>原因：地址错误</p>
<p>解决方法：localhost转为服务器IP</p>
<h4 id="问题四：容器创建、升级和删除后数据消失"><a href="#问题四：容器创建、升级和删除后数据消失" class="headerlink" title="问题四：容器创建、升级和删除后数据消失"></a>问题四：容器创建、升级和删除后数据消失</h4><p>解决方法：通过挂载的方式 将容器内的数据存储地址改为主机内</p>
<h4 id="问题五：容器之间相互隔离"><a href="#问题五：容器之间相互隔离" class="headerlink" title="问题五：容器之间相互隔离"></a>问题五：容器之间相互隔离</h4><p>建立自定义网络 将容器放在一个网络下</p>
<p>docker network connect multi-host-network my_container1</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/default-index/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/default-index/">1</a><a class="page-number" href="/default-index/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/default-index/page/4/">4</a><a class="page-number" href="/default-index/page/5/">5</a><a class="extend next" rel="next" href="/default-index/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">hnwu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hnwu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
