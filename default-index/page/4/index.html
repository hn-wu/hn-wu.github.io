<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="hnwu">
<meta property="og:url" content="http://example.com/default-index/page/4/index.html">
<meta property="og:site_name" content="hnwu">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="hnwu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/default-index/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>hnwu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hnwu</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/29/%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/29/%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81/" class="post-title-link" itemprop="url">内核态和用户态</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-29 19:31:06 / 修改时间：19:33:11" itemprop="dateCreated datePublished" datetime="2022-07-29T19:31:06+08:00">2022-07-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h2><h4 id="一、内核态和用户态"><a href="#一、内核态和用户态" class="headerlink" title="一、内核态和用户态"></a>一、内核态和用户态</h4><p>​	内核态其实从本质上说就是内核，它是一种<strong>特殊的软件程序，控制计算机的硬件资源，例如协调CPU资源，分配内存资源，并且提供稳定的环境供应用程序运行</strong>。</p>
<p>​	用户态就是提供应用程序运行的空间，为了使应用程序访问到内核管理的资源例如CPU，内存，I&#x2F;O。内核必须提供一组通用的访问接口，这些接口就叫<strong>系统调用。</strong></p>
<p>​	<strong>系统调用</strong>是操作系统的最小功能单位。根据不同的应用场景，不同的Linux发行版本提供的系统调用数量也不尽相同，大致在240-350之间。这些系统调用组成了用户态跟内核态交互的基本接口。</p>
<p><img src="https://api2.mubu.com/v3/document_image/f69b8c49-beff-4c0b-a05d-8dc76030cb85-12785011.jpg"></p>
<h4 id="二、为什么要区分内核态和用户态"><a href="#二、为什么要区分内核态和用户态" class="headerlink" title="二、为什么要区分内核态和用户态"></a>二、为什么要区分内核态和用户态</h4><p>​	在 CPU 的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，比如清内存、设置时钟等。如果允许所有的程序都可以使用这些指令，那么系统崩溃的概率将大大增加。</p>
<p>​	所以，CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通应用程序只能使用那些不会造成灾难的指令。</p>
<p>​	比如Intel的CPU将特权等级分为4个级别：Ring0~Ring3；Linux 系统只使用了Ring0和Ring3两个运行级别。当进程运行在Ring3级别时被称为运行在用户态，而运行在 Ring0 级别时被称为运行在内核态。因此可以说<strong>用户态与内核态的概念就是C P U 指令集权限的区别</strong></p>
<h4 id="三、内核态和用户态切换"><a href="#三、内核态和用户态切换" class="headerlink" title="三、内核态和用户态切换"></a>三、内核态和用户态切换</h4><p>​	<strong>用户程序有用户态和内核态两种状态</strong>。用户态就是执行在用户空间中，不能直接执行系统调用。必须先切换到内核态，也就是系统调用的相关数据信息必须存储在内核空间中，然后执行系统调用。</p>
<h5 id="（一）-系统调用"><a href="#（一）-系统调用" class="headerlink" title="（一） 系统调用"></a>（一） 系统调用</h5><p>​	操作系统对内核级别的指令进行封装，统一管理硬件资源，然后向用户程序提供系统服务，用户程序进行系统调用后，操作系统执行一系列的检查验证，确保这次调用是安全的，再进行相应的资源访问操作。比如C函数库中的内存分配函数malloc()，它具体是使用sbrk()系统调用来分配内存；当malloc调用sbrk()的时候就涉及一次从用户态到内核态的切换；类似的函数还有printf()，调用的是wirte()系统调用来输出字符串等等。</p>
<h5 id="（二）异常事件"><a href="#（二）异常事件" class="headerlink" title="（二）异常事件"></a>（二）异常事件</h5><p>​	当CPU正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，如缺页异常。</p>
<h5 id="（三）外围设备中断"><a href="#（三）外围设备中断" class="headerlink" title="（三）外围设备中断"></a>（三）外围设备中断</h5><p>​	当外围设备完成用户的请求操作后，会向CPU发出中断信号，此时，CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。</p>
<p><strong>PS：</strong>系统调用的本质其实也是中断，相对于外围设备的硬中断，这种中断称为软中断，这是操作系统为用户特别开放的一种中断。所以，从触发方式和效果上来看，这三种切换方式是完全一样的，都相当于是执行了一个中断响应的过程。但是从触发的对象来看，系统调用是进程主动请求切换的，而异常和硬中断则是被动的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/26/CAP%E5%8E%9F%E7%90%86%E5%92%8CBASE%E7%90%86%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/26/CAP%E5%8E%9F%E7%90%86%E5%92%8CBASE%E7%90%86%E8%AE%BA/" class="post-title-link" itemprop="url">CAP原理和BASE理论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-26 17:22:45 / 修改时间：17:23:53" itemprop="dateCreated datePublished" datetime="2022-07-26T17:22:45+08:00">2022-07-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一、CAP原理介绍"><a href="#一、CAP原理介绍" class="headerlink" title="一、CAP原理介绍"></a>一、CAP原理介绍</h3><h4 id="C：Consistency"><a href="#C：Consistency" class="headerlink" title="C：Consistency"></a>C：Consistency</h4><p>即一致性，访问所有的节点得到的数据应该是一样的。注意，这里的一致性指的是强一致性，也就是数据更新完，访问任何节点看到的数据完全一致，要和弱一致性，最终一致性区分开来。</p>
<h4 id="A：Availability"><a href="#A：Availability" class="headerlink" title="A：Availability"></a>A：Availability</h4><p>即可用性，所有的节点都保持高可用性。注意，这里的高可用还包括不能出现延迟，比如如果节点B由于等待数据同步而阻塞请求，那么节点B就不满足高可用性。</p>
<p>也就是说，任何没有发生故障的服务必须在有限的时间内返回合理的结果集。</p>
<h4 id="P：Partiton-tolerance"><a href="#P：Partiton-tolerance" class="headerlink" title="P：Partiton tolerance"></a>P：Partiton tolerance</h4><p>即分区容忍性，这里的分区是指网络意义上的分区。由于网络是不可靠的，所有节点之间很可能出现无法通讯的情况，在节点不能通信时，要保证系统可以继续正常服务。</p>
<hr>
一般来说，一个分布式系统不可能同时满足C和A和P这3个条件，因此在设计系统时候需要进行取舍。由于网络的不可靠性质，大多数开源的分布式系统都会实现P，也就是分区容忍性，之后在C和A中做抉择。

<h3 id="二、CAP场景分析"><a href="#二、CAP场景分析" class="headerlink" title="二、CAP场景分析"></a>二、CAP场景分析</h3><h4 id="在保证C和P的情况下"><a href="#在保证C和P的情况下" class="headerlink" title="在保证C和P的情况下"></a>在保证C和P的情况下</h4><p>为了保证数据一致性，data1需要将数据复制给data2，即data1和data2需要进行通信。但是由于网络是不可靠的，我们系统有保证了分区容忍性，也就是说这个系统是可以容忍网络的不可靠的。这时候data2就不一定能及时的收到data1的数据复制消息，当有请求向data2访问number数据时，为了保证数据的一致性，data2只能阻塞等待数据真正同步完成后再返回，这时候就没办法保证高可用性了。</p>
<p>所以，在保证C和P的情况下，是无法同时保证A的。</p>
<h4 id="在保证A和P的情况下"><a href="#在保证A和P的情况下" class="headerlink" title="在保证A和P的情况下"></a>在保证A和P的情况下</h4><p>为了保证高可用性，data1和data2都有在有限时间内返回。同样由于网络的不可靠，在有限时间内，data2有可能还没收到data1发来的数据更新消息，这时候返回给客户端的可能是旧的数据，和访问data1的数据是不一致的，也就是违法了C。</p>
<p>也就是说，在保证A和P的情况下，是无法同时保证C的。</p>
<h4 id="在保证A和C的情况下"><a href="#在保证A和C的情况下" class="headerlink" title="在保证A和C的情况下"></a>在保证A和C的情况下</h4><p>如果要保证高可用和一致性，只有在网络情况良好且可靠的情况下才能实现。这样data1才能立即将更新消息发送给data2。但是我们都知道网络是不可靠的，是会存在丢包的情况的。所以要满足即时可靠更新，只有将data1和data2放到一个区内才可以，也就丧失了P这个保证。其实这时候整个系统也不能算是一个分布式系统了。</p>
<h3 id="三、BASE理论"><a href="#三、BASE理论" class="headerlink" title="三、BASE理论"></a>三、BASE理论</h3><p>BASE 理论是针对 NoSQL 数据库而言的，它是对 CAP 理论中一致性（C）和可用性（A）进行权衡的结果，源于提出者自己在大规模分布式系统上实践的总结。其核心思想是无法做到强一致性，但每个应用都可以根据自身的特点，采用适当方式达到最终一致性。</p>
<h4 id="基本可用（Basically-Available）"><a href="#基本可用（Basically-Available）" class="headerlink" title="基本可用（Basically Available）"></a>基本可用（Basically Available）</h4><p>基本可用指分布式系统在出现故障时，系统允许损失部分可用性，即保证核心功能或者当前最重要功能可用。</p>
<p>对于用户来说，他们当前最关注的功能或者最常用的功能的可用性将会获得保证，但是其他功能会被削弱。</p>
<h4 id="软状态（Soft-state）"><a href="#软状态（Soft-state）" class="headerlink" title="软状态（Soft-state）"></a>软状态（Soft-state）</h4><p>软状态允许系统数据存在中间状态，但不会影响系统的整体可用性，即允许不同节点的副本之间存在暂时的不一致情况。</p>
<h4 id="最终一致性（Eventually-Consistent）"><a href="#最终一致性（Eventually-Consistent）" class="headerlink" title="最终一致性（Eventually Consistent）"></a>最终一致性（Eventually Consistent）</h4><p>最终一致性要求系统中数据副本最终能够一致，而不需要实时保证数据副本一致。例如，银行系统中的非实时转账操作，允许 24 小时内用户账户的状态在转账前后是不一致的，但 24 小时后账户数据必须正确。</p>
<p>最终一致性是 BASE 原理的核心，也是 NoSQL 数据库的主要特点，通过弱化一致性，提高系统的可伸缩性、可靠性和可用性。而且对于大多数 Web 应用，其实并不需要强一致性，因此牺牲一致性而换取高可用性，是多数分布式数据库产品的方向。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/25/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/25/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">进程通信方式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-25 15:36:27 / 修改时间：15:38:09" itemprop="dateCreated datePublished" datetime="2022-07-25T15:36:27+08:00">2022-07-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>进程通信方式<br>一、匿名管道<br>​ 匿名管道是内核中的一块缓冲区，是一种半双工通信方式，数据只能单向流动，通过使不同进程可以访问同一块缓冲区实现进程间通讯，但仅限本地父子进程之间通信</p>
<p>二、命名管道<br>​ 命名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p>
<p>三、消息队列<br>​ 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<p>四、共享内存<br>​ 共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p>
<p>五、信号量<br>​ 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<p>六、信号<br>​ 信号是Linux系统中用于进程之间通信或操作的一种机制，信号可以在任何时候发送给某一进程，而无须知道该进程的状态。如果该进程并未处于执行状态，则该信号就由内核保存起来，知道该进程恢复执行并传递给他为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。</p>
<p>七、套接字<br>​ 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/24/close-wait-time-wait/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/24/close-wait-time-wait/" class="post-title-link" itemprop="url">close_wait和time_wait</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-24 02:55:57 / 修改时间：02:59:13" itemprop="dateCreated datePublished" datetime="2022-07-24T02:55:57+08:00">2022-07-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TCP常用状态：<strong>ESTABLISHED</strong> 表示正在通信，<strong>TIME_WAIT</strong> 表示主动关闭，<strong>CLOSE_WAIT</strong> 表示被动关闭</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190828/8309948_1566974066111_035082E832E529B2DFF7F11FE4D076A4" alt="img"></p>
<h3 id="一、TIME-WAIT"><a href="#一、TIME-WAIT" class="headerlink" title="一、TIME_WAIT"></a>一、TIME_WAIT</h3><p>​	TIME_WAIT 是主动关闭链接时形成的，等待2MSL时间，约4分钟。主要是防止最后一个ACK丢失。 由于TIME_WAIT 的时间会非常长，因此server端应尽量减少主动关闭连接</p>
<p><strong>（一）为什么需要 TIME_WAIT 状态</strong></p>
<p>​	假设最终的ACK丢失，server将重发FIN，client必须维护TCP状态信息以便可以重发最终的ACK，否则会发送RST，结果server认为发生错误。TCP实现必须可靠地终止连接的两个方向(全双工关闭)，client必须进入 TIME_WAIT 状态，因为client可能面 临重发最终ACK的情形。</p>
<p><strong>（二）为什么 TIME_WAIT 状态需要保持 2MSL 这么长的时间</strong></p>
<p>​	如果 TIME_WAIT 状态保持时间不足够长(比如小于2MSL)，第一个连接就正常终止了。第二个拥有相同相关五元组的连接出现，而第一个连接的重复报文到达，干扰了第二个连接。TCP实现必须防止某个连接的重复报文在连接终止后出现，所以让TIME_WAIT状态保持时间足够长(2MSL)，连接相应方向上的TCP报文要么完全响应完毕，要么被 丢弃。建立第二个连接的时候，不会混淆。</p>
<p><strong>（三）time_wait产生过多原因</strong></p>
<p>​	正常的TCP客户端连接在关闭后，会进入一个TIME_WAIT的状态，持续的时间一般在1-4分钟，对于连接数不高的场景，1-4分钟其实并不长，对系统也不会有什么影响，但如果短时间内（例如1s内）进行大量的短连接，则可能出现这样一种情况：客户端所在的操作系统的socket端口和文件描述符被用尽，系统无法再发起新的连接！</p>
<p><strong>（四）time_wait过多解决方法</strong></p>
<ul>
<li>可以改为长连接，但代价较大，长连接太多会导致服务器性能问题；</li>
<li>修改ipv4.ip_local_port_range，增大可用端口范围，但只能缓解问题，不能根本解决问题；</li>
<li>客户端程序中设置socket的SO_LINGER选项；</li>
<li>客户端机器打开tcp_tw_recycle和tcp_timestamps选项；</li>
<li>客户端机器打开tcp_tw_reuse和tcp_timestamps选项；</li>
<li>客户端机器设置tcp_max_tw_buckets为一个很小的值；</li>
</ul>
<h3 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT"></a>CLOSE_WAIT</h3><p>​	CLOSE_WAIT是被动关闭连接是形成的。根据TCP状态机，服务器端收到客户端发送的FIN，则按照TCP实现发送ACK，因此进入CLOSE_WAIT状态。但如果服务器端不执行close()，就不能由CLOSE_WAIT迁移到LAST_ACK，则系统中会存在很多CLOSE_WAIT状态的连接。此时，可能是系统忙于处理读、写操作，而未将已收到FIN的连接，进行close。此时，recv&#x2F;read已收到FIN的连接socket，会返回0。</p>
<p><strong>（一）close_wait产生过多原因</strong></p>
<p>​	close_wait 按照正常操作的话应该很短暂的一个状态，接收到客户端的fin包并且回复客户端ack之后，会继续发送FIN包告知客户端关闭关闭连接，之后迁移到Last_ACK状态。但是close_wait过多只能说明没有迁移到Last_ACK，也就是服务端是否发送FIN包，只有发送FIN包才会发生迁移，所以问题定位在是否发送FIN包。FIN包的底层实现其实就是调用socket的close方法，这里的问题出在没有执行close方法。说明服务端socket忙于读写。</p>
<p><strong>（二）close_wait过多解决方法</strong></p>
<ul>
<li><p>使用完socket调用close方法；</p>
<p>socket读控制，当读取的长度为0时（读到结尾），立即close；</p>
<p>如果read返回-1，出现错误，检查error返回码，有三种情况：INTR（被中断，可以继续读取），WOULDBLOCK（表示当前socket_fd文件描述符是非阻塞的，但是现在被阻塞了），AGAIN（表示现在没有数据稍后重新读取）。如果不是AGAIN，立即close</p>
</li>
<li><p>可以设置TCP的连接时长keep_alive_time还有tcp监控连接的频率以及连接没有活动多长时间被迫断开连接</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/22/cpu%E7%BB%84%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/22/cpu%E7%BB%84%E6%88%90/" class="post-title-link" itemprop="url">cpu组成</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-22 00:41:04 / 修改时间：00:43:08" itemprop="dateCreated datePublished" datetime="2022-07-22T00:41:04+08:00">2022-07-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/" itemprop="url" rel="index"><span itemprop="name">计算机组成</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一、控制器，又叫控制单元（CU，Control-Unit）"><a href="#一、控制器，又叫控制单元（CU，Control-Unit）" class="headerlink" title="一、控制器，又叫控制单元（CU，Control Unit）"></a>一、控制器，又叫控制单元（CU，Control Unit）</h3><p>控制器的功能：<br>（1）从指令cache中取出一条指令，并指出下一条指令在指令cache中的位置。<br>（2）对指令进行译码或测试，并产生相应的操作控制信号，以便于启动规定的动作。例如：一次数据cache的读写操作，一个算术逻辑运算操作，一个输入输出操作。<br>（3）指挥并控制CPU，数据cache和输入输出设备之间数据流向的方向。</p>
<p>控制器内部的组成部分：</p>
<p>程序计数器（PC）：用来存放下一条要执行的指令的地址。<br>指令寄存器（IR）：用来存放当前正在执行的指令。<br>指令译码器（ID）：对指令进行“翻译”，确定指令执行什么操作，以决定操作的性质和方法。<br>控制电路：根据指令译码器的分析，发出控制信号，完成该指令的所有操作。<br>详细分析CPU取指的流程：<br>指令的地址保存在程序计数器（PC）中，取指过程中，不需要使用ALU，要想把指令从内存单元中取出来，先要知道指令的地址，即需要从PC中取出指令地址。PC先把指令地址传输到MAR（存储器地址寄存器），通过MAR把信号送到地址总线，最后送到存储器。这时存储器已经得到系统将要执行的指令地址。<br>然后由控制单元CU向存储器发出读命令，读出的数据由存储器通过数据总线送到MDR，再由MDR送到&#x3D;&#x3D;IR(指令寄存器)&#x3D;&#x3D;中。这是程序计数器PC自动加一，从而确定了下一条指令的地址。</p>
<h3 id="二、运算器，又叫算术逻辑单元（ALU，Arithmetic-Logic-Unit）"><a href="#二、运算器，又叫算术逻辑单元（ALU，Arithmetic-Logic-Unit）" class="headerlink" title="二、运算器，又叫算术逻辑单元（ALU，Arithmetic Logic Unit）"></a>二、运算器，又叫算术逻辑单元（ALU，Arithmetic Logic Unit）</h3><p>针对每一种算术运算，都必须有一个相对应的基本硬件配置，其核心部件是加法器和寄存器。<br>算术逻辑单元的功能：<br>（1）执行所有的算术运算。<br>（2）执行所有的逻辑运算，并进行逻辑测试。如零值测试或两个数的比较。</p>
<h3 id="三、寄存器"><a href="#三、寄存器" class="headerlink" title="三、寄存器"></a>三、寄存器</h3><p>寄存器是用来暂时保存运算和控制过程中的原始数据，中间结果，最终结果以及控制、状态信息的。CPU的寄存器被分为：用户可见寄存器、控制和状态寄存器</p>
<p><strong>用户可见寄存器</strong>：<br>（1）<strong>通用寄存器</strong>：存放原始数据和运算结果，可以作为某种寻址方式所需的专用寄存器。当算术逻辑单元ALU执行算数或逻辑运算时，通用寄存器为ALU提供一个工作区。现代计算机中，为了减少CPU访问存储器的次数，提高运算速度，往往设置大量的寄存器。通用寄存器一般由CPU直接访问，CPU对寄存器的访问速度远大于访问主存的速度。<br>（2）<strong>数据寄存器</strong>：存放操作数、运算结果和运算的中间结果，以减少访问存储器的次数，或者存放从存储器读取的数据以及写入存储器的数据的寄存器。寄存了将要写入到计算机主存储器（例如：RAM）的数据，或由计算机主存储器读取后的数据。它就像缓冲器，持有从内存复制的数据，以准备给处理器使用。<br>（3）<strong>地址寄存器</strong>：用来保存当前CPU所访问的内存单元的地址。由于在内存和CPU之间存在着操作速度上的差别，所以必须使用地址寄存器来保持地址信息，直到内存的读&#x2F;写操作完成为止 。<br>（4）<strong>条件码寄存器</strong>：存放条件码（条件码：体现当前指令执行结果的各种状态信息，如有无进位（CF位）、有无溢出（OV位）、结果正负（SF位）、结果是否为零（ZF位）、奇偶标志位（P位）等），可作程序分支的依据。</p>
<p><strong>控制和状态寄存器</strong><br>（1）<strong>控制寄存器</strong>：控制寄存器（CR0～CR3）用于控制和确定处理器的操作模式以及当前执行任务的特性。<br>（2）<strong>状态寄存器：</strong><br>状态寄存器：存放条件码<br>PSW寄存器：保存由算数指令和逻辑指令运算或测试结果建立的各种条形码；保存中断和系统工作状态等信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/21/java-thread-problems/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/21/java-thread-problems/" class="post-title-link" itemprop="url">Java并发问题及解决方案</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-21 18:27:12 / 修改时间：18:30:14" itemprop="dateCreated datePublished" datetime="2022-07-21T18:27:12+08:00">2022-07-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Java并发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="java并发问题及解决方案"><a href="#java并发问题及解决方案" class="headerlink" title="java并发问题及解决方案"></a>java并发问题及解决方案</h2><h3 id="一、为什么要多线程"><a href="#一、为什么要多线程" class="headerlink" title="一、为什么要多线程"></a>一、为什么要多线程</h3><p>1．耗时的操作使用线程，提高应用程序响应</p>
<p>2．并行操作时使用线程，如C&#x2F;S架构的服务器端并发线程响应用户的请求。</p>
<p>3．多CPU系统中，使用线程提高CPU利用率</p>
<p>4．改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独<br>立的运行部分，这样的程序会利于理解和修改。</p>
<h3 id="二、多线程有什么问题"><a href="#二、多线程有什么问题" class="headerlink" title="二、多线程有什么问题"></a>二、多线程有什么问题</h3><h4 id="（一）线程安全问题"><a href="#（一）线程安全问题" class="headerlink" title="（一）线程安全问题"></a>（一）线程安全问题</h4><p>在单线程系统上正常运行的代码，在多线程环境中可能会出现意料之外的结果<br>因此实现线程安全需要保证线程原子性、可见性</p>
<p>（1）原子性：<code>对数据的操作不会受其他线程打断</code>，意味着一个线程操作数据过程中不会插入其他线程对数据的操作<br>（2）可见性：<code>当线程修改了数据的状态时，能够立即被其他线程知晓</code>，即数据修改后会立即写入主内存，后续其他线程读取时就能得知数据的变化</p>
<p>每个线程都有自己的工作内存，工作内存和主存间要通过store和load进行交互，一旦线程1没有即使更新内存（从工作内存写回主存），那么线程2就无法获得正确数据</p>
<h4 id="二-活跃性问题"><a href="#二-活跃性问题" class="headerlink" title="(二)活跃性问题"></a>(二)活跃性问题</h4><p>活跃性：指”正确的是最终会发生“。<br>导致活跃性问题可能是由死锁、活锁、饥饿等引起的</p>
<p>死锁：死锁发生在一个线程需要获取多个资源的时候，这时由于两个线程互相等待对方的资源而被阻塞，死锁是最常见的活跃性问题。</p>
<p>活锁：活锁指的是线程不断重复执行相同的操作，但每次操作的结果都是失败的。尽管这个问题不会阻塞线程，但是程序也无法继续执行。</p>
<p>饥饿：饥饿指的线程无法访问到它需要的资源而不能继续执行时，引发饥饿最常见资源就是CPU时钟周期。</p>
<h4 id="三-性能问题"><a href="#三-性能问题" class="headerlink" title="(三)性能问题"></a>(三)性能问题</h4><p>​	即使没有如线程安全和死锁，活锁这些问题，多线程并发也不一定会快吗？因为多线程有<strong>线程创建</strong>和<strong>线程上下文切换</strong>的开销<br>​	创建线程是直接向操作系统申请资源，对操作系统来说创建一个线程的代价是十分昂贵的，需要给他分配内存，列入调度任务等，线程创建完了之后，还会遇到线程<strong>上下文</strong>切换</p>
<p>​	在多线程编程中，线程个数一般都大于 CPU 个数，而每个 CPU 在同一时刻只能被一个线程使用，为了让用户感觉多个线程是在同时执行的， CPU 资源的分配采用了时间片轮转策略 ，也就是给每个线程分配一个时间片。</p>
<p>​	<strong>线程在时间片内占用 CPU 执行任务。当线程使用完时间片后，就会变为就绪状态并让出 CPU</strong>，让其他线程占用 这就是上下文切换 ，从当前线程的上下文切换到了其他线程 。</p>
<p>​	让出 CPU 的线程等下次轮 到自己占有 CPU 时如何知道自己之前运行到哪里了？所以在切换线程上下文时需要保存当前线程的执行现场，当再次执行时，根据保存的执行现场信息恢复执行现场。</p>
<p>​	线程上下文切换时机有 </p>
<ul>
<li>当前线程的 CPU 时间片使用完处于就绪状态</li>
<li>当前线程被其他线程中断<br>一般减少上下文切换的方法有：<strong>无锁并发编程</strong>，<strong>CAS算法</strong>，<strong>使用协程</strong>等方式</li>
</ul>
<h3 id="三、如何解决这些问题"><a href="#三、如何解决这些问题" class="headerlink" title="三、如何解决这些问题"></a>三、如何解决这些问题</h3><h4 id="（一）互斥同步"><a href="#（一）互斥同步" class="headerlink" title="（一）互斥同步"></a>（一）互斥同步</h4><p>保证在多线程的环境下，一个资源在同一时刻只被一个线程使用</p>
<h4 id="（二）非阻塞同步"><a href="#（二）非阻塞同步" class="headerlink" title="（二）非阻塞同步"></a>（二）非阻塞同步</h4><p>实现非阻塞实现CAS需要三个操作数：内存地址，旧版本值，新版本值</p>
<p>当且仅当内存地址中存储的值与旧版本值相符时，才会进行操作，并更新新版本值</p>
<h4 id="（三）无同步方案"><a href="#（三）无同步方案" class="headerlink" title="（三）无同步方案"></a>（三）无同步方案</h4><p>1.可重入代码</p>
<p>​	这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p>
<p>​	可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p>
<p>2.线程本地存储（Thread Local Storage）</p>
<p>​	如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。</p>
<p>3.栈封闭</p>
<p>​	多个线程访问同一个方法的局部变量</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/21/redis-singleThread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/21/redis-singleThread/" class="post-title-link" itemprop="url">Redis单线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-21 17:37:09 / 修改时间：17:39:12" itemprop="dateCreated datePublished" datetime="2022-07-21T17:37:09+08:00">2022-07-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Reids/" itemprop="url" rel="index"><span itemprop="name">Reids</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Redis单线程"><a href="#Redis单线程" class="headerlink" title="Redis单线程"></a>Redis单线程</h2><p>　　我们通常说，Redis是单线程，主要是指Redis的网络I&#x2F;O和键值读写的是由一个线程来完成的。其他数据持久化、集群数据同步、异步删除等，其实是由额外线程来完成的。</p>
<p>　　所以，严格来说，Redis 并不是单线程，但是我们一般把 Redis 称为单线程高性能。接下来，会把 Redis 称为单线程模式。我们会想到：“为什么用单线程？为什么单线程能这么快？</p>
<p><strong>一、Redis为什么这么快？</strong></p>
<p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p>
<p>2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p>
<p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p>
<p>4、使用多路I&#x2F;O复用模型，非阻塞IO；</p>
<p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p>
<p><strong>多路 I&#x2F;O 复用模型介绍</strong></p>
<p>多路I&#x2F;O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I&#x2F;O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I&#x2F;O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p>
<p><strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong></p>
<p>采用多路 I&#x2F;O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p>
<p><strong>二、为什么Redis是单线程的？</strong></p>
<p>官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。</p>
<p>但是，我们使用单线程的方式是无法发挥多核CPU 性能，不过我们可以通过在单机开多个Redis 实例来完善！</p>
<p>注意Redis的单线程，只是在处理我们的网络请求的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！例如Redis进行持久化的时候会以子进程或者子线程的方式执行（具体是子线程还是子进程待读者深入研究）；例如我在测试服务器上查看Redis进程，然后找到该进程下的线程：</p>
<p><img src="https://img.php.cn/upload/image/996/736/192/1620787926409192.png" alt="4.png"></p>
<p>ps命令的“-T”参数表示显示线程（Show threads, possibly with SPID column.）“SID”栏表示线程ID，而“CMD”栏则显示了线程名称。</p>
<p>警告2：在上图中FAQ中的最后一段，表述了从Redis 4.0版本开始会支持多线程的方式，但是，只是在某一些操作上进行多线程的操作！所以该篇文章在以后的版本中是否还是单线程的方式需要读者考证！</p>
<p><strong>三、注意点</strong></p>
<p>1、我们知道Redis是用”单线程-多路复用IO模型”来实现高性能的内存数据服务的，这种机制避免了使用锁，但是同时这种机制在进行sunion之类的比较耗时的命令时会使redis的并发下降。</p>
<p>因为是单一线程，所以同一时刻只有一个操作在进行，所以，耗时的命令会导致并发的下降，不只是读并发，写并发也会下降。而单一线程也只能用到一个CPU核心，所以可以在同一个多核的服务器中，可以启动多个实例，组成master-master或者master-slave的形式，耗时的读命令可以完全在slave进行。</p>
<p>需要改的redis.conf项：</p>
<p>pidfile &#x2F;var&#x2F;run&#x2F;redis&#x2F;redis_6377.pid #pidfile要加上端口号</p>
<p>port 6377 #这个是必须改的</p>
<p>logfile &#x2F;var&#x2F;log&#x2F;redis&#x2F;redis_6377.log #logfile的名称也加上端口号</p>
<p>dbfilename dump_6377.rdb #rdbfile也加上端口号</p>
<p>2、“我们不能任由操作系统负载均衡，因为我们自己更了解自己的程序，所以，我们可以手动地为其分配CPU核，而不会过多地占用CPU，或是让我们关键进程和一堆别的进程挤在一起。”</p>
<p>CPU 是一个重要的影响因素，由于是单线程模型，Redis 更喜欢大缓存快速 CPU， 而不是多核。</p>
<p>在多核 CPU 服务器上面，Redis 的性能还依赖NUMA 配置和处理器绑定位置。最明显的影响是 redis-benchmark 会随机使用CPU内核。为了获得精准的结果，需要使用固定处理器工具（在 Linux 上可以使用 taskset）。最有效的办法是将客户端和服务端分离到两个不同的 CPU 来高校使用三级缓存。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/20/java-variate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/20/java-variate/" class="post-title-link" itemprop="url">Java变量</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-20 16:37:03 / 修改时间：16:47:22" itemprop="dateCreated datePublished" datetime="2022-07-20T16:37:03+08:00">2022-07-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Java变量"><a href="#Java变量" class="headerlink" title="Java变量"></a>Java变量</h2><h3 id="一、成员变量"><a href="#一、成员变量" class="headerlink" title="一、成员变量"></a>一、成员变量</h3><p>方法外部，类内部定义的变量<br><strong>（一）类变量(静态变量)：独立于方法之外的变量，用 static 修饰</strong>。</p>
<p>​	类变量也称为静态变量，在类中以static关键字声明，但必须在方法构造方法和语句块之外。<br>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。<br>​	静态变量除了被声明为常量外很少使用。常量是指声明为public&#x2F;private，final和static类型的变量。常量初始化后不可改变。<br>​	静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。<br>​	静态变量在第一次被访问时创建，在程序结束时销毁。<br>​	与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。<br>​	默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以	在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。<br>​	静态变量可以通过：ClassName.VariableName的方式访问。<br>​	类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。<br><strong>（二）实例变量(非静态变量)：独立于方法之外的变量，不过没有 static 修饰。</strong></p>
<p>​	实例变量声明在一个类中，但在方法、构造方法和语句块之外；<br>​	当一个对象被实例化之后，每个实例变量的值就跟着确定；<br>​	实例变量在对象创建的时候创建，在对象被销毁的时候销毁；<br>​	实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；<br>​	实例变量可以声明在使用前或者使用后；<br>​	访问修饰符可以修饰实例变量；<br>​	实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；<br>​	实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；<br>​	实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：	ObejectReference.VariableName。</p>
<h4 id="类变量和实例变量的区别"><a href="#类变量和实例变量的区别" class="headerlink" title="类变量和实例变量的区别"></a><strong>类变量和实例变量的区别</strong></h4><p><strong>调用方式</strong><br>静态变量也称为类变量，可以直接通过类名调用。也可以通过对象名调用。这个变量属于类。<br>成员变量也称为实例变量，只能通过对象名调用。这个变量属于对象。</p>
<p><strong>存储位置</strong><br>静态变量存储在方法区中的静态区。<br>成员变量存储在堆内存。</p>
<p><strong>生命周期</strong><br>静态变量随着类的加载而存在，随着类的消失而消失。生命周期长。<br>成员变量随着对象的创建而存在，随着对象的消失而消失。</p>
<p><strong>与对象的相关性</strong><br>静态变量是所有对象共享的数据。<br>成员变量是每个对象所特有的数据。</p>
<h3 id="二、局部变量"><a href="#二、局部变量" class="headerlink" title="二、局部变量"></a>二、局部变量</h3><p>局部变量：类的方法中的变量。</p>
<p>局部变量声明在方法、构造方法或者语句块中；</p>
<p>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</p>
<p>访问修饰符不能用于局部变量；</p>
<p>局部变量只在声明它的方法、构造方法或者语句块中可见；</p>
<p>局部变量是在栈上分配的。</p>
<p>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</p>
<h3 id="三、成员变量和局部变量的区别"><a href="#三、成员变量和局部变量的区别" class="headerlink" title="三、成员变量和局部变量的区别"></a>三、成员变量和局部变量的区别</h3><p><strong>作用域</strong><br>成员变量：针对整个类有效。<br>局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)</p>
<p><strong>存储位置</strong><br>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在<strong>堆内存</strong>中。<br>局部变量：在方法被调用，或者语句被执行的时候存在，存储在<strong>栈内存</strong>中。当方法调用完，或者语句结束后，就自动释放。</p>
<p><strong>生命周期</strong><br>成员变量：随着对象的创建而存在，随着对象的消失而消失<br>局部变量：当方法调用完，或者语句结束后，就自动释放。</p>
<p><strong>初始值</strong><br>成员变量：有默认初始值。<br>局部变量：没有默认初始值，使用前必须赋值。-</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/19/springBean-lifeCycle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/19/springBean-lifeCycle/" class="post-title-link" itemprop="url">Spring生命周期</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-19 16:41:35 / 修改时间：16:45:26" itemprop="dateCreated datePublished" datetime="2022-07-19T16:41:35+08:00">2022-07-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Spring生命周期"><a href="#Spring生命周期" class="headerlink" title="Spring生命周期"></a>Spring生命周期</h2><p>Bean的生命周期大体包括4个阶段：<strong>实例化 &gt; 属性赋值 &gt; 初始化 &gt; 使用 &gt; 销毁</strong></p>
<p>Bean 生命周期的整个执行过程描述如下。</p>
<p><strong>实例化</strong></p>
<ol>
<li><p>Spring 启动，查找并加载需要被 Spring 管理的 Bean，对 Bean 进行实例化。</p>
<p><strong>属性赋值</strong></p>
</li>
<li><p>对 Bean 进行属性注入。</p>
<p><strong>初始化</strong></p>
</li>
<li><p>如果 Bean 实现了 BeanNameAware 接口，则 Spring 调用 Bean 的 setBeanName() 方法传入当前 Bean 的 id 值。</p>
</li>
<li><p>如果 Bean 实现了 BeanFactoryAware 接口，则 Spring 调用 setBeanFactory() 方法传入当前工厂实例的引用。</p>
</li>
<li><p>如果 Bean 实现了 ApplicationContextAware 接口，则 Spring 调用 setApplicationContext() 方法传入当前 ApplicationContext 实例的引用。</p>
</li>
<li><p>如果 Bean 实现了 BeanPostProcessor 接口，则 Spring 调用该接口的预初始化方法 postProcessBeforeInitialzation() 对 Bean 进行加工操作，此处非常重要，Spring 的 AOP 就是利用它实现的。</p>
</li>
<li><p>如果 Bean 实现了 InitializingBean 接口，则 Spring 将调用 afterPropertiesSet() 方法。</p>
</li>
<li><p>如果在配置文件中通过 init-method 属性指定了初始化方法，则调用该初始化方法。</p>
</li>
<li><p>如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的初始化方法 postProcessAfterInitialization()。此时，Bean 已经可以被应用系统使用了。</p>
<p><strong>销毁</strong></p>
</li>
<li><p>如果 Bean 实现了 DisposableBean 接口，则 Spring 会调用 destory() 方法销毁 Bean；如果在配置文件中通过 destory-method 属性指定了 Bean 的销毁方法，则 Spring 将调用该方法对 Bean 进行销毁。</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e8a473640bcd06e544c86fa729133ac3.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/18/mysql-isolation-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hnwu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hnwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/18/mysql-isolation-md/" class="post-title-link" itemprop="url">数据库的隔离级别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-18 16:26:25" itemprop="dateCreated datePublished" datetime="2022-07-18T16:26:25+08:00">2022-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-19 16:44:11" itemprop="dateModified" datetime="2022-07-19T16:44:11+08:00">2022-07-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="数据库的隔离级别"><a href="#数据库的隔离级别" class="headerlink" title="数据库的隔离级别"></a>数据库的隔离级别</h3><p>数据库事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 。而且，在事务的并发操作中可能会出现脏读，不可重复读，幻读。下面通过事例一一阐述它们的概念与联系。</p>
<p>　　<strong>脏读、不可重复读、幻象读</strong>概念说明：　　</p>
<ol>
<li>脏读：指当一个事务正在访问数据，并且对数据进行了修改，而这种数据还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。依据脏数据所做的操作肯能是不正确的。</li>
<li>不可重复读：指在一个事务内，多次读同一数据。在这个事务还没有执行结束，另外一个事务也访问该同一数据，那么在第一个事务中的两次读取数据之间，由于第二个事务的修改第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事物内两次连续读到的数据是不一样的，这种情况被称为是不可重复读。</li>
<li>幻读：一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻象读（两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中）</li>
</ol>
<hr>
<p> <strong>读未提交 （Read uncommitted）</strong></p>
<p>　　读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。</p>
<p>　　事例：老板要给程序员发工资，程序员的工资是3.6万&#x2F;月。但是发工资时老板不小心按错了数字，按成3.9万&#x2F;月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。</p>
<p>　　分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。因此，在这种隔离级别下，查询是不会加锁的，也由于查询的不加锁，所以这种隔离级别的一致性是最差的，可能会产生“脏读”、“不可重复读”、“幻读”。如无特殊情况，基本是不会使用这种隔离级别的。</p>
<p>　　那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。</p>
<hr>
<p> <strong>读提交（Read Committed）</strong></p>
<p>　　读提交，顾名思义，就是只能读到已经提交了的内容</p>
<p>　　事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…</p>
<p>　　分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。</p>
<p> 　这是各种系统中最常用的一种隔离级别，也是SQL Server和Oracle的默认隔离级别。这种隔离级别能够有效的避免脏读，但除非在查询中显示的加锁，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from T where ID=2 lock in share mode;</span><br><span class="line">select * from T where ID=2 for update;</span><br></pre></td></tr></table></figure>

<p>　　不然，普通的查询是不会加锁的。</p>
<p>　　那为什么“读提交”同“读未提交”一样，都没有查询加锁，但是却能够避免脏读呢？</p>
<p>　　这就要说道另一个机制“快照（snapshot）”，而这种既能保证一致性又不加锁的读也被称为“快照读（Snapshot Read）”</p>
<p>　　假设没有“快照读”，那么当一个更新的事务没有提交时，另一个对更新数据进行查询的事务会因为无法查询而被阻塞（因为上了X锁，即写锁，所以不能得到S锁，即读锁），这种情况下，并发能力就相当的差。而“快照读”就可以完成高并发的查询，不过，“读提交”只能避免“脏读”，并不能避免“不可重复读”和“幻读”。</p>
<p>　　那怎么解决可能的不可重复读问题？Repeatable read ！</p>
<hr>
<p><strong>可重复读(Repeated Read)</strong></p>
<p>　　可重复读，顾名思义，就是专门针对“不可重复读”这种情况而制定的隔离级别，自然，它就可以有效的避免“不可重复读”。而它也是MySql的默认隔离级别。</p>
<p>　　事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。</p>
<p>　　分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。</p>
<p>什么时候会出现幻读？</p>
<p>　　事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。</p>
<p>　　在这个级别下，普通的查询同样是使用的“快照读”，但是，和“读提交”不同的是，当事务启动时，就不允许进行“修改操作（Update）”了，而“不可重复读”恰恰是因为两次读取之间进行了数据的修改，因此，“可重复读”能够有效的避免“不可重复读”，但却避免不了“幻读”，因为幻读是由于“插入或者删除操作（Insert or Delete）”而产生的。</p>
<p>　　那怎么解决幻读问题？Serializable！</p>
<hr>
<p><strong>序列化 *<em>Serializable*</em></strong></p>
<p>　　这是数据库最高的隔离级别，这种级别下，事务“串行化顺序执行”，也就是一个一个排队执行。这种级别下，“脏读”、“不可重复读”、“幻读”都可以被避免，但是执行效率奇差，性能开销也最大，所以基本没人会用。</p>
<hr>
<p>值得一提的是：大多数数据库默认的事务隔离级别是Read committed，比如Sql Server , Oracle。Mysql的默认隔离级别是Repeatable read。</p>
<p> <strong>MySql如何解决幻读问题？</strong></p>
<p>（1）<strong>什么是幻读</strong></p>
<ul>
<li><strong>前提条件</strong>：InnoDB引擎，可重复读隔离级别，使用当前读时。</li>
</ul>
<p>　  在一次事务里面，多次查询之后，结果集的个数不一致的情况叫做幻读。而多出来或者少的哪一行被叫做 幻行</p>
<ul>
<li><strong>表现</strong>：一个事务(同一个read view)在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行。两点需要说明：<br>　　1、在可重复读隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的，幻读只在当前读下才会出现。<br>　　2、幻读专指新插入的行，读到原本存在行的更新结果不算。因为当前读的作用就是能读到所有已经提交记录的最新值。</li>
</ul>
<p><strong>（2）幻读产生的原因</strong></p>
<p>　　行锁只能锁住行，即使把所有的行记录都上锁，也阻止不了新插入的记录。 </p>
<p><strong>（3）如何解决幻读？</strong></p>
<ul>
<li>在快照读读情况下，mysql通过mvcc来避免幻读。</li>
<li>在当前读读情况下，mysql通过next-key来避免幻读</li>
</ul>
<p><strong>备注：什么是快照读、当前读</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- 快照读, 读取专门的快照 (对于RC，快照（ReadView）会在每个语句中创建。对于RR，快照是在事务启动时创建的)</span><br><span class="line">```</span><br><span class="line">简单的select操作即可(不需要加锁,如: select ... lock in share mode, select ... for update)</span><br><span class="line">```</span><br><span class="line">针对的也是select操作</span><br><span class="line"></span><br><span class="line">- 当前读, 读取最新版本的记录, 没有快照。 在InnoDB中，当前读取根本不会创建任何快照。</span><br><span class="line">```</span><br><span class="line">select ... lock in share mode</span><br><span class="line"></span><br><span class="line">select ... for update</span><br><span class="line"></span><br><span class="line">insert</span><br><span class="line"></span><br><span class="line">update</span><br><span class="line"></span><br><span class="line">delete</span><br><span class="line"></span><br><span class="line">针对如下操作, 会让如下操作阻塞:    </span><br><span class="line">```</span><br><span class="line">insert</span><br><span class="line">update</span><br><span class="line">delete</span><br><span class="line">```</span><br><span class="line">- 在RR(可重复读)级别下, 快照读是通过MVVC(多版本控制)和undo log来实现的,</span><br><span class="line"></span><br><span class="line">当前读是通过手动加record lock(记录锁)和gap lock(间隙锁)来实现的。所以从上面的显示来看，如果需要实时显示数据，还是需要通过加锁来实现。这个时候会使用next-key技术来实现。所以说</span><br></pre></td></tr></table></figure>

<p><strong>总结一下：</strong></p>
<ul>
<li>为什么会出现“脏读”？因为没有“select”操作没有规矩。</li>
<li>为什么会出现“不可重复读”？因为“update”操作没有规矩。</li>
<li>为什么会出现“幻读”？因为“insert”和“delete”操作没有规矩。</li>
<li>“读未提（Read Uncommitted）”能预防啥？啥都预防不了。</li>
<li>“读提交（Read Committed）”能预防啥？使用“快照读（Snapshot Read）”，避免“脏读”，但是可能出现“不可重复读”和“幻读”。</li>
<li>“可重复读（Repeated Red）”能预防啥？使用“快照读（Snapshot Read）”，锁住被读取记录，避免出现“脏读”、“不可重复读”，但是可能出现“幻读”。</li>
<li>“串行化（Serializable）”能预防啥？排排坐，吃果果，有效避免“脏读”、“不可重复读”、“幻读”，不过效果谁用谁知道。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/default-index/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/default-index/">1</a><span class="space">&hellip;</span><a class="page-number" href="/default-index/page/3/">3</a><span class="page-number current">4</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">hnwu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hnwu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
